{
  "createdAt": "2025-05-01T14:25:34.686Z",
  "updatedAt": "2025-05-05T13:13:03.000Z",
  "id": "4knuqjqMJ0PLaqoY",
  "name": "YouTube AI analys",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {}
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        0,
        0
      ],
      "id": "542dc144-25f4-47a2-9087-b1cfac13077e",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "resource": "playlistItem",
        "operation": "getAll",
        "playlistId": "=UUPjNBjflYl0-HQtUvOx0Ibw",
        "part": [
          "snippet",
          "contentDetails"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.youTube",
      "typeVersion": 1,
      "position": [
        220,
        -500
      ],
      "id": "1a068f33-e325-47d8-8f29-c6dc7793defc",
      "name": "Greg Isenberg",
      "credentials": {
        "youTubeOAuth2Api": {
          "id": "LnAQTPv3vaELYS2I",
          "name": "YouTube Parser n8n"
        }
      }
    },
    {
      "parameters": {
        "resource": "playlistItem",
        "operation": "getAll",
        "playlistId": "=UUbo-KbSjJDG6JWQ_MTZ_rNA",
        "part": [
          "snippet",
          "contentDetails"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.youTube",
      "typeVersion": 1,
      "position": [
        220,
        -300
      ],
      "id": "900640c4-c00f-49f5-8cd7-9d3829aac422",
      "name": "Nick Saraev",
      "credentials": {
        "youTubeOAuth2Api": {
          "id": "LnAQTPv3vaELYS2I",
          "name": "YouTube Parser n8n"
        }
      }
    },
    {
      "parameters": {
        "resource": "playlistItem",
        "operation": "getAll",
        "playlistId": "=UU08Fah8EIryeOZRkjBRohcQ",
        "part": [
          "snippet",
          "contentDetails"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.youTube",
      "typeVersion": 1,
      "position": [
        220,
        -120
      ],
      "id": "40ca1cbc-5aef-48d0-aea3-089d799f6825",
      "name": "Creator Magic",
      "credentials": {
        "youTubeOAuth2Api": {
          "id": "LnAQTPv3vaELYS2I",
          "name": "YouTube Parser n8n"
        }
      }
    },
    {
      "parameters": {
        "resource": "playlistItem",
        "operation": "getAll",
        "playlistId": "=UUMwVTLZIRRUyyVrkjDpn4pA",
        "part": [
          "snippet",
          "contentDetails"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.youTube",
      "typeVersion": 1,
      "position": [
        220,
        120
      ],
      "id": "3d5d3f74-d3e1-4b12-a8d6-3696dbbdfa84",
      "name": "Cole Medin",
      "credentials": {
        "youTubeOAuth2Api": {
          "id": "LnAQTPv3vaELYS2I",
          "name": "YouTube Parser n8n"
        }
      }
    },
    {
      "parameters": {
        "resource": "playlistItem",
        "operation": "getAll",
        "playlistId": "=UUI4xxi0p97BghIqgEPYx6sw",
        "part": [
          "snippet",
          "contentDetails"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.youTube",
      "typeVersion": 1,
      "position": [
        220,
        320
      ],
      "id": "4d90034a-3366-42fd-8209-6bba486affdf",
      "name": "Your AI Workflow",
      "credentials": {
        "youTubeOAuth2Api": {
          "id": "LnAQTPv3vaELYS2I",
          "name": "YouTube Parser n8n"
        }
      }
    },
    {
      "parameters": {
        "resource": "playlistItem",
        "operation": "getAll",
        "playlistId": "=UUc-FovAyBAQDw2Y7PQ_v0Zw",
        "part": [
          "snippet",
          "contentDetails"
        ],
        "options": {}
      },
      "type": "n8n-nodes-base.youTube",
      "typeVersion": 1,
      "position": [
        220,
        520
      ],
      "id": "57e2f9c8-48e9-4e6f-b229-b6ce5b8f9539",
      "name": "Julian Goldie SEO",
      "credentials": {
        "youTubeOAuth2Api": {
          "id": "LnAQTPv3vaELYS2I",
          "name": "YouTube Parser n8n"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// отфильтровать только элементы без ошибки и с определённым transcript\nreturn items.filter(item => {\n  // если есть поле error или transcript === undefined, пропускаем\n  if (item.json.error) return false;\n  if (item.json.transcript === undefined) return false;\n  return true;\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1980,
        -20
      ],
      "id": "bb78f923-8449-4bf6-88ff-f1028cb00ebf",
      "name": "Error Filter"
    },
    {
      "parameters": {
        "url": "https://youtube-transcript3.p.rapidapi.com/api/transcript",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "videoId",
              "value": "={{ $json.videoId }}"
            },
            {
              "name": "Title",
              "value": "={{ $json.title }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "=X-RapidAPI-Host",
              "value": "=youtube-transcript3.p.rapidapi.com"
            },
            {
              "name": "=X-RapidAPI-Key",
              "value": "=f7f02f04f5mshc37f3e7eedb6f29p111f4djsn60e622f16916"
            }
          ]
        },
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 100000
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1480,
        -180
      ],
      "id": "7ffd3eee-efff-4825-809b-33d7e0aa1757",
      "name": "youtube video parser"
    },
    {
      "parameters": {
        "jsCode": "// вычисляем метку времени «неделю назад»\nconst oneWeekAgo = Date.now() - 1 * 24 * 60 * 60 * 1000;\n\n// фильтруем элементы по дате публикации из snippet.publishedAt\nconst recentItems = items.filter(item => {\n  const pubDate = new Date(item.json.snippet.publishedAt).getTime();\n  return pubDate >= oneWeekAgo;\n});\n\nreturn recentItems;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        -20
      ],
      "id": "25249b4c-315f-4cc3-96fc-91e00a76a907",
      "name": "24 hours"
    },
    {
      "parameters": {
        "jsCode": "// объединим все сегменты transcript в один текст\nconst segs = $json.transcript || [];\nconst fullText = segs.map(s => s.text).join(' ');\n// передадим дальше оригинальные поля + новое\nreturn [{\n  json: {\n    ...$json,\n    transcript_original: fullText\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        -20
      ],
      "id": "11690ba9-a3f8-4925-9fd4-b52ca86461dc",
      "name": "add transcript_original"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 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"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "application/json",
        "body": "={{\n  JSON.stringify({\n    model: \"google/gemini-2.5-pro-exp-03-25\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are an instructional designer. Given the user’s transcript text, identify the 4–6 major topics covered and for each provide a concise, detailed description (2–3 sentences). Output the result as a JSON array of objects with the schema [{\\\"topic\\\":\\\"...\\\",\\\"detail\\\":\\\"...\\\"}, …]. Do not add any extra commentary.\"\n      },\n      {\n        role: \"user\",\n        content: $json.chunk\n      }\n    ]\n  })\n}}\n",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 10000
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3180,
        -160
      ],
      "id": "a4dd0a31-cf26-4290-bde5-defe8016e61e",
      "name": "Chat Completion"
    },
    {
      "parameters": {
        "jsCode": "// Берём исходный текст и метаданные из первого элемента\nconst input = items[0].json;\nconst fullText = input.choices[0].message.content;\nconst { title, url, publishedAt, videoId } = input;\n\n// Максимальная длина чанка\nconst maxLen = 3000;\n\n// Разбиваем на массив предложений (учитываем точки, воскл. и вопросит. знаки)\nconst sentences = fullText.match(/[^\\.!\\?]+[\\.!\\?]+/g) || [fullText];\n\n// Накопитель\nlet chunks = [];\nlet current = '';\n\n// Проходим по каждому предложению\nfor (const sentence of sentences) {\n  if ((current + sentence).length <= maxLen) {\n    current += sentence + ' ';\n  } else {\n    if (current) chunks.push(current.trim());\n    current = sentence + ' ';\n  }\n}\n// Последний чанк\nif (current) chunks.push(current.trim());\n\n// Преобразуем в items, добавляя метаданные только в первый\nreturn chunks.map((textChunk, index) => {\n  const base = { chunk: textChunk };\n  if (index === 0) {\n    // добавляем поля только для первого элемента\n    return {\n      json: {\n        ...base,\n        title,\n        url,\n        publishedAt,\n        videoId,\n      },\n    };\n  }\n  // последующие — только chunk\n  return { json: base };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2960,
        -20
      ],
      "id": "cfbef56e-90f4-4384-a1b4-3390054695a7",
      "name": "Split to Chunks"
    },
    {
      "parameters": {
        "jsCode": "// Инициализируем пустую строку для сбора текста из всех входных айтемов\nlet allFullText = '';\n\n// Переменные для метаданных, берем их из первого айтема\nlet title, url, publishedAt, videoId;\n\n// Берем метаданные только из первого входного айтема, если он существует\nif (items.length > 0 && items[0].json) {\n  const firstItemJson = items[0].json;\n  title = firstItemJson.title;\n  url = firstItemJson.url;\n  publishedAt = firstItemJson.publishedAt;\n  videoId = firstItemJson.videoId;\n}\n\n\n// Проходим по всем входным айтемам и собираем текст\nfor (const item of items) {\n  // Проверяем, существует ли поле с текстом в текущем айтеме\n  if (item.json && item.json.choices && item.json.choices[0] && item.json.choices[0].message && item.json.choices[0].message.content) {\n    // Добавляем текст текущего айтема к общей строке.\n    // Добавляем перевод строки между текстами разных айтемов для лучшего разделения.\n    allFullText += item.json.choices[0].message.content + '\\n';\n  }\n}\n\n// Максимальная длина чанка (остается прежней)\nconst maxLen = 3000;\n\n// Разбиваем объединенный текст на предложения\n// Учитываем случай, если allFullText пустой\nconst sentences = allFullText.match(/[^\\.!\\?]+[\\.!\\?]+/g) || (allFullText ? [allFullText] : []);\n\n\n// Собираем чанки из объединенных предложений (логика остается прежней)\nlet chunks = [];\nlet current = '';\nfor (const sentence of sentences) {\n  // Убираем лишние пробелы из начала/конца предложения перед проверкой длины\n  const trimmedSentence = sentence.trim();\n  if (!trimmedSentence) continue; // Пропускаем пустые строки после trim\n\n  // Проверяем, поместится ли предложение в текущий чанк\n  // Учитываем пробел, который добавим после предложения\n  if ((current + trimmedSentence).length + (current ? 1 : 0) <= maxLen) {\n    current += trimmedSentence + ' ';\n  } else {\n    // Если текущий чанк не пустой, добавляем его в список чанков\n    if (current) chunks.push(current.trim());\n    // Начинаем новый чанк с текущего предложения\n    current = trimmedSentence + ' ';\n  }\n}\n// Добавляем последний чанк, если он не пустой\nif (current) chunks.push(current.trim());\n\n\n// Преобразуем чанки в выходные айтемы.\n// Метаданные добавляем только к первому чанку общего текста.\nreturn chunks.map((text, idx) => {\n  const base = { summary_points: text };\n  if (idx === 0) {\n    // Только в первом выходном айтеме (первом чанке) добавляем метаданные из первого входного айтема\n    return {\n      json: {\n        ...base,\n        title, // Метаданные из первого входного айтема\n        url,\n        publishedAt,\n        videoId,\n      }\n    };\n  }\n  // Для последующих чанков возвращаем только текст\n  return { json: base };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3640,
        -20
      ],
      "id": "de080fd8-d7aa-4c0c-b76b-4634851217df",
      "name": "Summarizer"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "60d0d292-7f04-40b4-acf3-8a64c13acd26",
              "name": "title",
              "value": "={{ $json.snippet.title }}",
              "type": "string"
            },
            {
              "id": "753c7ef6-4008-4b16-81f0-7fbe291f015a",
              "name": "url",
              "value": "=https://youtube.com/watch?v={{ $json.snippet.resourceId.videoId }}",
              "type": "string"
            },
            {
              "id": "b51008a2-7ca7-408c-b212-f8a441d7c3e5",
              "name": "publishedAt",
              "value": "={{ $json.snippet.publishedAt }}",
              "type": "string"
            },
            {
              "id": "32915e1e-22a5-452f-a234-8371d3993da3",
              "name": "videoId",
              "value": "={{ $json.snippet.resourceId.videoId }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1260,
        -20
      ],
      "id": "d0e6b142-8d7d-4a02-af47-6f6dbc0be845",
      "name": "Parse title ulr and publishedAt"
    },
    {
      "parameters": {
        "jsCode": "// Node 1: Clean the raw string containing the JSON array\n\n// Инициализируем переменную для сбора всех частей сырой JSON строки из входных айтемов\nlet combinedRawJsonString = '';\n\n// Переменные для метаданных, берем их из первого входного айтема\nlet title, url;\n\n// Берем метаданные (title, url) только из первого входного айтема, если он существует\nif (items.length > 0 && items[0].json) {\n    const firstInputItemJson = items[0].json;\n    title = firstInputItemJson.title;\n    url = firstInputItemJson.url;\n    // publishedAt и videoId также доступны, но в оригинале не использовались в выходе этого узла.\n}\n\n// Проходим по всем входным айтемам и собираем содержимое поля summary_points\nfor (const item of items) {\n    // Проверяем, существует ли поле summary_points в текущем айтеме\n    if (item.json && item.json.summary_points) {\n        // Добавляем содержимое summary_points текущего айтема к общей строке\n        // Просто конкатенируем, т.к. чистка ниже должна справиться с возможными разрывами\n        combinedRawJsonString += item.json.summary_points;\n    }\n}\n\n// Теперь работаем с объединенной сырой строкой\nlet cleanedJsonString = combinedRawJsonString;\n\n// --- Cleaning Steps ---\n\n// 1. Remove potential leading 'json' marker and surrounding whitespace/newlines.\ncleanedJsonString = cleanedJsonString.replace(/^\\s*```?\\s*json\\s*\\n*/, '');\n\n// 2. Remove potential trailing backticks (``` or `) and surrounding whitespace/newlines.\ncleanedJsonString = cleanedJsonString.replace(/\\s*```?\\s*$/, '');\n\n// 3. Trim any remaining leading/trailing whitespace.\ncleanedJsonString = cleanedJsonString.trim();\n\n// --- !!! WARNING !!! ---\n// The following step removes JSON structure characters ([ ] { }).\n// As noted in the original code, this makes the string invalid JSON and JSON.parse() in the next node WILL FAIL\n// if the next node expects valid JSON. This logic is kept as per your original code.\n\n// 4. Remove square brackets ([ ]) and curly braces ({ }) using a regex\ncleanedJsonString = cleanedJsonString.replace(/[\\[\\]\\{\\}]/g, '');\n\n// --- Prepare Output for the next node ---\n// Мы возвращаем один айтем, содержащий очищенную объединенную строку и метаданные из первого входного айтема.\nreturn [{\n    json: {\n        cleanedJsonString: cleanedJsonString, // Очищенная объединенная строка\n        title: title,                         // Оригинальный title из первого входного айтема\n        url: url                              // Оригинальный URL из первого входного айтема\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3900,
        -20
      ],
      "id": "1e5cc7c5-6547-44ce-b307-46945c4372ae",
      "name": "remove json"
    },
    {
      "parameters": {
        "jsCode": "// Получаем очищенную строку из предыдущего узла\nconst cleanedJsonString = items[0].json.cleanedJsonString;\n\n// Шаблон для парсинга — регулярное выражение для извлечения topic и detail\nconst regex = /\"topic\":\\s*\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"\\s*,\\s*\"detail\":\\s*\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/gs;\n\n// Массив для хранения результата\nlet result = [];\nlet match;\n\n// Извлекаем метаданные из первого элемента\nconst title = items[0].json.title;\nconst url = items[0].json.url;\n\n// Проходим по строкам и извлекаем значения для topic и description\nlet isFirstRow = true; // Переменная для отслеживания первой строки\nwhile ((match = regex.exec(cleanedJsonString)) !== null) {\n    // match[1] содержит значение 'topic'\n    // match[3] содержит значение 'detail'\n    let row = {\n        json: {\n            Topic: match[1],       // Тема\n            Description: match[3]  // Описание\n        }\n    };\n\n    // Добавляем title и url только для первой строки\n    if (isFirstRow) {\n        row.json.title = title;\n        row.json.url = url;\n        isFirstRow = false; // После первой строки устанавливаем флаг в false\n    }\n\n    result.push(row);\n}\n\n// Возвращаем результат в формате, где каждая строка представляет собой объект с Topic, Description, title и url (для первой строки)\nreturn result;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4120,
        -20
      ],
      "id": "a4710b64-f678-422a-b41b-9cb0433a109b",
      "name": "Code"
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "https://docs.google.com/spreadsheets/d/1pongTk5EFZI1D6RRpYwz_Ex_Tt3lsHfD0jHcGgnAq0k/edit?usp=sharing",
          "mode": "url"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Parsing",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1pongTk5EFZI1D6RRpYwz_Ex_Tt3lsHfD0jHcGgnAq0k/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Title": "={{ $json.title }}",
            "Topic": "={{ $json.Topic }}",
            "Description": "={{ $json.Description }}",
            "Link": "={{ $json.url }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "Title",
              "displayName": "Title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Topic",
              "displayName": "Topic",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Description",
              "displayName": "Description",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Link",
              "displayName": "Link",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [
        4580,
        100
      ],
      "id": "dfcc26a9-bcdd-4d32-9476-f205b0fe0c31",
      "name": "Google Sheets",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "JWf1dYTj83NVJtf5",
          "name": "Google Sheets account 2"
        }
      }
    },
    {
      "parameters": {
        "model": "google/gemma-3-27b-it",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        3760,
        400
      ],
      "id": "ddbacad6-ee9f-4226-a888-5082dd83c405",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "xM1Kdr0j4QvJ4iaw",
          "name": "AdminN8N"
        }
      }
    },
    {
      "parameters": {
        "model": "openai/gpt-4.1",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        3760,
        700
      ],
      "id": "ffd44774-8420-4578-b69b-ec3e33f4f469",
      "name": "OpenRouter Chat Model1",
      "credentials": {
        "openRouterApi": {
          "id": "xM1Kdr0j4QvJ4iaw",
          "name": "AdminN8N"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "=Authorization",
              "value": "=Bearer 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"
            },
            {
              "name": "=Content-Type",
              "value": "=application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "application/json",
        "body": "={\n  \"model\": \"google/gemini-2.5-pro-exp-03-25\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You are a translator. Your only task is to take the user’s input and output its English translation — nothing more. Do not add any commentary, explanations, apologies or extra sentences. If the input is already English, return it verbatim.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.transcript_original }}\"\n    }\n  ]\n}\n",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2420,
        -160
      ],
      "id": "b8257f31-848d-430b-ba31-9362ca99fd9d",
      "name": "HTTP OpenRouter Request"
    },
    {
      "parameters": {
        "numberInputs": 6
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        720,
        -80
      ],
      "id": "c0794ac1-4a45-48bf-b6e2-71624e0e41a5",
      "name": "Merge YouTube videos"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        1700,
        -40
      ],
      "id": "72845b20-1e57-4adb-98f1-da266ced7ca4",
      "name": "Merge transcribation and title, url,  etc"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        2700,
        -20
      ],
      "id": "6b565cff-30ed-4ca2-ae86-a18d07ecb4e4",
      "name": "Merge OpenRouter and transcript"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        3420,
        -20
      ],
      "id": "d175c838-8fff-4687-8af1-03fd4f0a33f0",
      "name": "Merge Chunks and title, url, etc"
    },
    {
      "parameters": {
        "jsCode": "// Получаем входные данные\nconst inputData = items;  // Это таблица с колонками Topic, Description и Title\n\n// Массив для хранения результата\nlet result = [];\n\n// Получаем title и url только из первого элемента\nconst title = inputData[0].json.title;\nconst url = inputData[0].json.url;\n\n// Переменная для отслеживания первой строки\nlet isFirstRow = true;\n\n// Проходим по всем строкам и добавляем title и url только для первой строки\ninputData.forEach(item => {\n    // Создаем объект для каждой строки\n    const row = {\n        json: {\n            Topic: item.json.Topic,          // Извлекаем Topic\n            Description: item.json.Description,  // Извлекаем Description\n            title: title  // Дублируем Title из первого элемента\n        }\n    };\n\n    // Добавляем url только для первой строки\n    if (isFirstRow) {\n        row.json.url = url;\n        isFirstRow = false; // После первой строки устанавливаем флаг в false\n    }\n\n    result.push(row);\n});\n\n// Возвращаем результат\nreturn result;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3440,
        260
      ],
      "id": "47088f8f-6f3c-4c8c-a225-7fd9b4946038",
      "name": "Add Titles to rows"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Generate a lesson theory without bullet points and description what students will be able to..., This project/learning centers/module... Write text like guide, not water AI answer using this materials:\nTitle: {{ $json.title }}\nTopic: {{ $json.Topic }}\nDescription: {{ $json.Description }}\n\nU need to write 2-3 paragraphs about Description that i gave you\n\nStart output from \"Lesson Description:\" \n\nDo not add any extra commentary\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        3660,
        260
      ],
      "id": "2df03b0a-ea95-463b-aeda-af0ecfd917ff",
      "name": "Theory Generator"
    },
    {
      "parameters": {
        "jsCode": "// Получаем все входные данные (input items)\nconst inputItems = items;\n\n// Массив для хранения результата\nlet mergedResult = [];\nlet fullText = '';  // Это будет наш объединенный текст\n\n// Проходим по всем входным данным и собираем текст\ninputItems.forEach(item => {\n    const lessonText = item.json.text;  // Извлекаем текст из каждого input\n\n    // Добавляем разрыв строки перед \"Lesson Description\", если это нужно\n    const formattedText = lessonText.replace(/(Lesson Description)/g, '\\n$1');\n    \n    // Добавляем к полному тексту\n    fullText += formattedText + ' ';\n});\n\n// Формируем итоговый объект\nmergedResult.push({\n    json: {\n        lessonText: fullText.trim()  // Склеиваем все Lesson Description в один блок\n    }\n});\n\n// Возвращаем объединенные данные\nreturn mergedResult;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4020,
        260
      ],
      "id": "514c7f49-e326-45ec-b777-898d810593ed",
      "name": "Theory Merger"
    },
    {
      "parameters": {
        "jsCode": "// Получаем динамический текст из входных данных\nconst inputString = $input.first().json.lessonText;\n\n// Функция для добавления числовых индексов перед каждым \"Lesson Description:\"\nconst addLessonNumber = (input) => {\n  let count = 1;\n  // Используем регулярное выражение для поиска всех вхождений \"Lesson Description:\"\n  return input.replace(/(Lesson Description:)/g, () => {\n    return `Lesson Description ${count++}:`;  // Вставляем номер урока перед \"Lesson Description:\"\n  });\n};\n\n// Применяем функцию добавления номеров уроков\nconst updatedString = addLessonNumber(inputString);\n\n// Возвращаем результат\nreturn [{ json: { updatedText: updatedString } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3440,
        540
      ],
      "id": "54831ec2-5b87-4a7a-86ca-ecd9418a8c13",
      "name": "Add nums to Lesson Description"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Не пиши коментарии от себя\n\nЯ хочу преобразовать следующий текст в JSON-формат для описания онлайн-курса.\nОбщая информация о курсе:\nНа основе всего предоставленного текста сгенерируй общее название для курса (название не должно быть очень длинным, несколько слов).\nНа основе всего предоставленного текста сгенерируй общее описание для курса.\nКатегория курса: 680f332a16f8bb2b6ce9e71d\nУровень сложности: beginner\nИзображение курса: (оставьте пустым)\nПревью изображения курса: (оставьте пустым)\nМодули курса:\nДля каждого блока текста, начинающегося с \"Lesson Description\" и заканчивающегося перед следующим \"Lesson Description\" (или концом текста), создай отдельный модуль в массиве \"modules\".\nДля каждого модуля:\nЗаголовок модуля: Сгенерируй краткий заголовок, обобщающий содержание текущего \"Lesson Description\".\nОписание модуля: Сгенерируй краткое описание, обобщающее содержание текущего \"Lesson Description\".\nСодержание модуля (\"content\"): Скопируй полностью текст текущего \"Lesson Description\".\nУроки модуля (\"lessons\"): Создай массив, содержащий один объект урока.\nЗаголовок урока (\"title\"): Сформируй заголовок как \"Module №X\", где X - порядковый номер текущего \"Lesson Description\".\nСодержание урока (\"content\"): Скопируй полностью текст текущего \"Lesson Description\".\nДлительность урока (\"duration\"): 15\nТип урока (\"type\"): text\nТип контента (\"contentType\"): standard\nРесурсы урока (\"resources\"): []\nПрактические упражнения урока (\"practiceExercises\"): []\nБлоки контента урока (\"contentBlock\"): []\nТесты модуля (\"tests\"): []\nВходной текст:\n{{ $json.updatedText }}\nJSON Structure:\n{\n\"title\": \"(сгенерированное название курса)\",\n\"description\": \"(сгенерированное описание курса)\",\n\"category\": \"680f332a16f8bb2b6ce9e71d\",\n\"difficulty\": \"beginner\",\n\"image\": \"\",\n\"imagePreview\": \"\",\n\"modules\": [\n{\n\"title\": \"(сгенерированный заголовок модуля 1)\",\n\"description\": \"(сгенерированное описание модуля 1)\",\n\"content\": \"(текст Lesson Description 1)\",\n\"lessons\": [\n{\n\"title\": \"Module №1\",\n\"content\": \"(текст Lesson Description 1)\",\n\"duration\": 15,\n\"type\": \"text\",\n\"contentType\": \"standard\",\n\"resources\": [],\n\"practiceExercises\": [],\n\"contentBlocks\": []\n}\n],\n\"tests\": []\n},\n{\n\"title\": \"(сгенерированный заголовок модуля 2)\",\n\"description\": \"(сгенерированное описание модуля 2)\",\n\"content\": \"(текст Lesson Description 2)\",\n\"lessons\": [\n{\n\"title\": \"Module №2\",\n\"content\": \"(текст Lesson Description 2)\",\n\"duration\": 15,\n\"type\": \"text\",\n\"contentType\": \"standard\",\n\"resources\": [],\n\"practiceExercises\": [],\n\"contentBlocks\": []\n}\n],\n\"tests\": []\n},\n// ... и так далее для каждого Lesson Description должен быть сгенерирован модуль\n]\n}\nВажно: Обрати внимание, что общая информация о курсе (title, description, category, difficulty, image, imagePreview) указывается только один раз в начале JSON. Массив \"modules\" содержит объекты для каждого \"Lesson Description\". и Пиши на английском"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        3660,
        540
      ],
      "id": "285282a8-0eea-4415-a72b-48978fbee0cc",
      "name": "JSON generator"
    },
    {
      "parameters": {
        "jsCode": "// Получаем динамический текст из входных данных\nconst inputString = $input.first().json.text;\n\n// Функция для удаления лишних символов\nconst cleanString = (input) => {\n  return input\n    .replace(/```json\\n/g, '') // Убираем начало блока json\n    .replace(/```/g, '') // Убираем окончание блока json\n    .replace(/\\n/g, ' ') // Заменяем все \\n на пробелы\n    .replace(/\\s+/g, ' ') // Убираем лишние пробелы (заменяем несколько пробелов на один)\n    .trim(); // Убираем пробелы в начале и в конце\n};\n\n// Применяем функцию очистки\nconst cleanedString = cleanString(inputString);\n\n// Возвращаем очищенную строку\nreturn [{ json: { cleanedText: cleanedString } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4020,
        540
      ],
      "id": "a0e348b8-e19b-4181-a19c-045bffd036c7",
      "name": "Delete trash"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Greg Isenberg",
            "type": "main",
            "index": 0
          },
          {
            "node": "Nick Saraev",
            "type": "main",
            "index": 0
          },
          {
            "node": "Creator Magic",
            "type": "main",
            "index": 0
          },
          {
            "node": "Cole Medin",
            "type": "main",
            "index": 0
          },
          {
            "node": "Your AI Workflow",
            "type": "main",
            "index": 0
          },
          {
            "node": "Julian Goldie SEO",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Greg Isenberg": {
      "main": [
        [
          {
            "node": "Merge YouTube videos",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Nick Saraev": {
      "main": [
        [
          {
            "node": "Merge YouTube videos",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Creator Magic": {
      "main": [
        [
          {
            "node": "Merge YouTube videos",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Cole Medin": {
      "main": [
        [
          {
            "node": "Merge YouTube videos",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Your AI Workflow": {
      "main": [
        [
          {
            "node": "Merge YouTube videos",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Julian Goldie SEO": {
      "main": [
        [
          {
            "node": "Merge YouTube videos",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "youtube video parser": {
      "main": [
        [
          {
            "node": "Merge transcribation and title, url,  etc",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "24 hours": {
      "main": [
        [
          {
            "node": "Parse title ulr and publishedAt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Filter": {
      "main": [
        [
          {
            "node": "add transcript_original",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "add transcript_original": {
      "main": [
        [
          {
            "node": "HTTP OpenRouter Request",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge OpenRouter and transcript",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Split to Chunks": {
      "main": [
        [
          {
            "node": "Chat Completion",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Chunks and title, url, etc",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Chat Completion": {
      "main": [
        [
          {
            "node": "Merge Chunks and title, url, etc",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarizer": {
      "main": [
        [
          {
            "node": "remove json",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse title ulr and publishedAt": {
      "main": [
        [
          {
            "node": "youtube video parser",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge transcribation and title, url,  etc",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "remove json": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Add Titles to rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Theory Generator",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "JSON generator",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "HTTP OpenRouter Request": {
      "main": [
        [
          {
            "node": "Merge OpenRouter and transcript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge YouTube videos": {
      "main": [
        [
          {
            "node": "24 hours",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge transcribation and title, url,  etc": {
      "main": [
        [
          {
            "node": "Error Filter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge OpenRouter and transcript": {
      "main": [
        [
          {
            "node": "Split to Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Chunks and title, url, etc": {
      "main": [
        [
          {
            "node": "Summarizer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Titles to rows": {
      "main": [
        [
          {
            "node": "Theory Generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Theory Generator": {
      "main": [
        [
          {
            "node": "Theory Merger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Theory Merger": {
      "main": [
        [
          {
            "node": "Add nums to Lesson Description",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add nums to Lesson Description": {
      "main": [
        [
          {
            "node": "JSON generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JSON generator": {
      "main": [
        [
          {
            "node": "Delete trash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": {
    "node:Schedule Trigger": {
      "recurrenceRules": []
    }
  },
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "62e8ae1b-8f6f-4b1f-8119-9b7d5cefeaa2",
  "triggerCount": 1,
  "tags": []
}