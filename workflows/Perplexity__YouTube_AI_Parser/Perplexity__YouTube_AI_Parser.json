{
  "createdAt": "2025-05-05T13:31:29.614Z",
  "updatedAt": "2025-05-09T19:41:24.000Z",
  "id": "RoUKvfOsZAN3t7YP",
  "name": "Perplexity + YouTube AI Parser",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "method": "POST",
        "url": "https://hook.eu2.make.com/ha0xladgffsp156aqzplnmlxwx8iq5np",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "message",
              "value": "=Find 5 YouTube videos about 'AI Agents scraping or MCP for scrapping web sites' uploaded in 2025. Return video title, full video link, and full channel link in tablesheet format\n\nPlease provide me output only with extracted information in structured format, without \"okay i need, i will give you or something else\""
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -180,
        -40
      ],
      "id": "66b97695-baf8-42ab-bc1d-bd376a6860e2",
      "name": "HTTP Request to make.com"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {}
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -500,
        -40
      ],
      "id": "d380d7fa-cf63-4f58-997e-b0be1c21aa14",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "jsCode": "function cleanText(inputText) {\n  if (typeof inputText !== 'string') {\n    // В реальной среде автоматизации лучше выбрасывать ошибку\n    // throw new Error(\"Input must be a string.\");\n    console.error(\"Input must be a string.\");\n    return ''; // Возвращаем пустую строку в случае ошибки типа\n  }\n  const thinkTagRegex = /<think>.*?<\\/think>/gs;\n  let cleanedText = inputText.replace(thinkTagRegex, '');\n  const bracketNumberRegex = /\\[\\d+\\]/g;\n  cleanedText = cleanedText.replace(bracketNumberRegex, '');\n  return cleanedText;\n}\n\n/**\n * Cleans the input text and structures the result as an array of objects,\n * where each object represents a non-empty line from the cleaned text.\n * (Без изменений)\n * @param {string} inputText The original string with think tags and bracketed numbers.\n * @returns {Array<object>} An array of objects, e.g., [{ id: 0, lineContent: \"...\" }, ...].\n */\nfunction cleanAndStructureOutput(inputText) {\n  const cleanedFullText = cleanText(inputText);\n  const lines = cleanedFullText.split('\\n');\n  const outputArray = [];\n  let idCounter = 0;\n  for (const line of lines) {\n    const trimmedLine = line.trim();\n    if (trimmedLine !== '') {\n      outputArray.push({\n        id: idCounter++,\n        lineContent: trimmedLine\n      });\n    }\n  }\n  return outputArray;\n}\n\nconst text = $input.first().json.data; // Или $input[0].json.data в стандартном JS\nconst result = cleanAndStructureOutput(text);\nreturn result;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        120,
        -40
      ],
      "id": "113fa118-cc3a-4f49-9e9e-c8b947b84f79",
      "name": "Cleans text and splits into lines"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst joinedText = items.map(item => item.json.lineContent).join('\\n');\nreturn [{ json: { joinedText } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        -40
      ],
      "id": "827187ba-5f46-4042-9e85-824b32a701d1",
      "name": "Joins lines into single text"
    },
    {
      "parameters": {
        "jsCode": "// JavaScript code for n8n to parse YouTube data into a table with three columns\n// Input: $input.first().json.joinedText\n// Output: Array of objects with videoTitle, videoLink, and channelLink\n\nfunction processYoutubeData(inputText) {\n  const result = [];\n  \n  // Split by lines\n  const lines = inputText.split('\\n');\n  \n  // Variables to track data positions\n  let isDataRow = false;\n  let currentTitle = '';\n  let currentVideoLink = '';\n  let currentChannelLink = '';\n  \n  // Process each line\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    \n    // Skip empty lines\n    if (!line) continue;\n    \n    // Check if this is the header line\n    if (line.includes('Video Title') && line.includes('Full Video Link') && line.includes('Full Channel Link')) {\n      isDataRow = true;\n      continue;\n    }\n    \n    // Skip separator lines\n    if (line.includes('----')) {\n      continue;\n    }\n    \n    // If we've found data rows\n    if (isDataRow) {\n      // If the line contains multiple fields separated by '|'\n      if (line.includes('|')) {\n        const parts = line.split('|').map(part => part.trim()).filter(Boolean);\n        \n        // Check if this is the start of a new entry\n        if (parts.length >= 1) {\n          // If we have collected a complete entry before, add it to results\n          if (currentTitle && currentVideoLink) {\n            result.push({\n              videoTitle: currentTitle,\n              videoLink: currentVideoLink,\n              channelLink: currentChannelLink\n            });\n          }\n          \n          // Reset for new entry\n          currentTitle = '';\n          currentVideoLink = '';\n          currentChannelLink = '';\n          \n          // Extract data from parts\n          for (const part of parts) {\n            // Check if part is a video title (no URL)\n            if (!part.includes('http')) {\n              // Skip \"\\\\n\" markers\n              if (part === '\\\\n' || part === '\\n') continue;\n              \n              // If we don't have a title yet, this is the title\n              if (!currentTitle) {\n                currentTitle = part;\n                continue;\n              }\n            }\n            \n            // Check if part is a video link\n            if (part.includes('youtube.com/watch?v=')) {\n              currentVideoLink = part;\n              continue;\n            }\n            \n            // Check if part is a channel link\n            if (part.includes('youtube.com/') && !part.includes('watch?v=')) {\n              currentChannelLink = part;\n              continue;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Add the last entry if there is one\n  if (currentTitle && currentVideoLink) {\n    result.push({\n      videoTitle: currentTitle,\n      videoLink: currentVideoLink,\n      channelLink: currentChannelLink\n    });\n  }\n  \n  return result;\n}\n\n// Main execution for n8n\nconst inputText = $input.first().json.joinedText;\nconst parsedData = processYoutubeData(inputText);\n\n// Return the processed data\nreturn {\n  json: {\n    tableData: parsedData\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        -180
      ],
      "id": "90ab205d-a04b-4da6-8d64-37f0ca0c5c2b",
      "name": "Code"
    },
    {
      "parameters": {
        "jsCode": "// отфильтровать только элементы без ошибки и с определённым transcript\nreturn items.filter(item => {\n  // если есть поле error или transcript === undefined, пропускаем\n  if (item.json.error) return false;\n  if (item.json.transcript === undefined) return false;\n  return true;\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2040,
        -460
      ],
      "id": "3e8756ae-d86b-45b1-bc9f-62b57b8dd0f3",
      "name": "Error Filter"
    },
    {
      "parameters": {
        "jsCode": "// объединим все сегменты transcript в один текст\nconst segs = $json.transcript || [];\nconst fullText = segs.map(s => s.text).join(' ');\n// передадим дальше оригинальные поля + новое\nreturn [{\n  json: {\n    ...$json,\n    transcript_original: fullText\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2300,
        -460
      ],
      "id": "7188bc75-a65b-46e6-a778-d265dd6253b8",
      "name": "add transcript_original"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 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"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "application/json",
        "body": "={{\n  JSON.stringify({\n    model: \"google/gemma-3-27b-it\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are an instructional designer. Given the user’s transcript text, identify the 4–6 major topics covered and for each provide a concise, detailed description (2–3 sentences). Output the result as a JSON array of objects with the schema [{\\\"topic\\\":\\\"...\\\",\\\"detail\\\":\\\"...\\\"}, …]. Do not add any extra commentary.\"\n      },\n      {\n        role: \"user\",\n        content: $json.chunk\n      }\n    ]\n  })\n}}\n",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 10000
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2160,
        140
      ],
      "id": "1674eb9b-2bee-43b5-86ff-01f8b160d429",
      "name": "Chat Completion"
    },
    {
      "parameters": {
        "jsCode": "// Этот код предназначен для использования в ноде \"Function\" в n8n.\n// Он принимает массив элементов, каждый из которых содержит JSON с полем\n// 'concatenatedTranscript' и метаданными.\n// Код разбивает каждый 'concatenatedTranscript' на более мелкие чанки,\n// стремясь заполнить чанки до maxLen и ища точку разбиения (конец предложения)\n// в \"окне\" перед концом чанка.\n// Метаданные из входного элемента дублируются в каждом выходном чанке\n// с использованием тех же имен полей, что и во входящих:\n// title, video_url, video_id, channel_url.\n\n// Массив для сбора всех результирующих чанков из всех входящих элементов.\n// Каждый элемент этого массива станет отдельным выходным элементом из ноды Function.\nconst outputItems = [];\n\n// Максимальная длина чанка в символах.\nconst maxLen = 3000;\n\n// Размер \"окна\" в символах в конце потенциального чанка,\n// в котором мы будем искать точку разбиения (конец предложения).\nconst splitWindow = 300; // Например, ищем в последних 300 символах перед лимитом\n\n// Проходим по каждому входящему элементу, который поступил в эту ноду.\nfor (const item of items) {\n\n    // --- Извлечение данных из текущего входящего элемента ---\n\n    // Получаем текст для разбивки. Предполагается, что он находится в item.json.concatenatedTranscript.\n    const fullText = item.json.concatenatedTranscript;\n\n    // Получаем метаданные. Используем имена полей, как в ваших примерах ($input.first().json....).\n    // !!! Убедитесь, что эти поля (title, video_url, video_id, channel_url)\n    // !!! точно соответствуют названиям полей в вашем входящем JSON.\n    const { title, video_url, video_id, channel_url } = item.json;\n\n    // --- Обработка и разбиение текста ---\n\n    // Проверяем, существует ли текст для обработки. Если нет, пропускаем этот элемент.\n    if (!fullText) {\n        console.warn('Skipping item with missing or empty concatenatedTranscript:', item);\n        continue; // Переходим к следующему входящему элементу\n    }\n\n    const itemChunksText = []; // Массив для строковых чанков, созданных из *текущего* входящего элемента\n    let currentIndex = 0; // Текущая позиция в исходном тексте\n\n    // Цикл продолжается, пока мы не обработаем весь текст\n    while (currentIndex < fullText.length) {\n\n        // Определяем максимально возможный конец текущего чанка ( currentIndex + maxLen )\n        let potentialChunkEndIndex = Math.min(currentIndex + maxLen, fullText.length);\n\n         // Если оставшийся текст меньше или равен maxLen (с небольшим запасом, чтобы не искать окно в конце),\n        // или мы в конце текста, просто берем весь оставшийся текст как последний чанк.\n        // Добавим условие: если оставшийся текст меньше окна + небольшой буфер, просто берем остаток.\n        if (fullText.length - currentIndex <= splitWindow * 1.5 || potentialChunkEndIndex === fullText.length) {\n             itemChunksText.push(fullText.substring(currentIndex).trim());\n             currentIndex = fullText.length; // Сдвигаем индекс на конец, чтобы выйти из цикла\n             break; // Выходим из цикла обработки текста для текущего элемента\n        }\n\n        // --- Поиск точки разбиения в \"окне\" ---\n\n        // Определяем начало окна для поиска точки разбиения.\n        // Ищем в последних 'splitWindow' символах потенциального чанка,\n        // но не раньше начала текущей позиции (currentIndex).\n        const searchStart = Math.max(currentIndex, potentialChunkEndIndex - splitWindow);\n\n        let bestSplitIndex = -1; // Индекс наилучшей найденной точки разбиения (после символа)\n\n        // Идем назад от конца потенциального чанка к началу окна поиска\n        for (let i = potentialChunkEndIndex - 1; i >= searchStart; i--) {\n            const char = fullText[i];\n\n            // Ищем конец предложения: точка, восклицательный или вопросительный знак\n            if (char === '.' || char === '!' || char === '?') {\n                 // Проверяем, что за знаком препинания следует пробел ИЛИ это конец строки в пределах потенциального чанка\n                 // /\\s/.test(fullText[i + 1]) проверяет, является ли следующий символ пробельным (пробел, табуляция, новая строка)\n                 if (i + 1 < fullText.length && /\\s/.test(fullText[i + 1]) || i + 1 === potentialChunkEndIndex) {\n                     bestSplitIndex = i + 1; // Точка разбиения - сразу ПОСЛЕ знака препинания (и пробела, если есть)\n                     break; // Нашли последнюю подходящую точку в окне, используем ее\n                 }\n            }\n        }\n\n        // --- Определение окончательной точки разбиения чанка ---\n\n        let finalSplitIndex;\n\n        if (bestSplitIndex !== -1) {\n            // Если нашли подходящую точку разбиения в окне, используем ее.\n            // Убедимся, что точка разбиения находится после начала текущего чанка.\n             if (bestSplitIndex > currentIndex) {\n                finalSplitIndex = bestSplitIndex;\n            } else {\n                 // Если bestSplitIndex <= currentIndex, это означает, что ближайшая точка\n                 // препинания с пробелом находится ДО начала текущего чанка или прямо в начале.\n                 // В этом случае делаем разбиение по maxLen как запасной вариант.\n                 finalSplitIndex = potentialChunkEndIndex;\n            }\n\n        } else {\n            // Если не нашли подходящую точку разбиения в окне,\n            // делаем разбиение по maxLen. Это может разорвать предложение.\n            finalSplitIndex = potentialChunkEndIndex;\n        }\n\n        // --- Создание чанка и обновление позиции ---\n\n        // Выделяем текст чанка от текущей позиции до найденной точки разбиения.\n        const chunkText = fullText.substring(currentIndex, finalSplitIndex).trim();\n\n        // Добавляем созданный текстовый чанк в массив чанков текущего элемента, если он не пуст.\n        if (chunkText.length > 0) {\n            itemChunksText.push(chunkText);\n        } else {\n             // Если получился пустой чанк (очень редко, но может быть), сдвигаем currentIndex\n             // хотя бы на 1, чтобы избежать бесконечного цикла.\n             console.warn(`Created an empty chunk for item ${item.id || 'N/A'} starting at index ${currentIndex}. Adjusting index.`);\n             currentIndex++; // Сдвигаем вперед, чтобы не зависнуть\n             continue; // Пропускаем добавление пустого чанка и переходим к следующей итерации\n        }\n\n\n        // Обновляем текущую позицию на конец только что созданного чанка.\n        currentIndex = finalSplitIndex;\n\n        // Пропускаем любые пробелы или символы новой строки сразу после точки разбиения,\n        // чтобы следующий чанк не начинался с них.\n         while (currentIndex < fullText.length && /\\s/.test(fullText[currentIndex])) {\n            currentIndex++;\n        }\n\n\n    } // Конец while цикла для обработки текста одного элемента\n\n\n    // --- Формирование выходных элементов для текущего входящего элемента ---\n\n    // Преобразуем созданные строковые чанки в формат элементов n8n\n    // и добавляем метаданные из текущего входящего элемента К КАЖДОМУ чанку.\n    // Используем имена полей, как в ваших примерах ($input.first().json....).\n    const outputItemChunks = itemChunksText.map(textChunk => {\n        return {\n            json: {\n                chunk: textChunk,       // Сам текст чанка\n                title: title,           // Метаданные: title\n                video_url: video_url,   // Метаданные: video_url\n                video_id: video_id,     // Метаданные: video_id\n                channel_url: channel_url, // Метаданные: channel_url\n                // Если у вас есть другие поля, которые должны дублироваться, добавьте их здесь.\n            },\n        };\n    });\n\n    // Добавляем все созданные для *текущего* входящего элемента чанки\n    // в общий массив результатов, который будет возвращен нодой.\n    outputItems.push(...outputItemChunks);\n\n} // Конец for цикла для обработки всех входящих элементов\n\n// Возвращаем общий массив всех чанков, собранных из всех входных элементов.\n// Каждый элемент в этом массиве станет отдельным выходным элементом из этой ноды.\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1880,
        260
      ],
      "id": "edbab663-9ce6-47a3-b663-cab58130b046",
      "name": "Split to Chunks"
    },
    {
      "parameters": {
        "jsCode": "// Предполагается, что $input.all() предоставляет массив объектов\nconst items = $input.all();\n\nif (!items || items.length === 0) {\n  return [];\n}\n\nconst mergedData = {}; // Объект для накопления данных\n// Переменные для статистики (если они вам нужны для других целей, иначе можно удалить)\n// let processedItemsCount = 0;\n// let skippedItemsCount = 0;\n// let skippedContentCount = 0;\n\nfor (const item of items) {\n  // processedItemsCount++; // Если статистика нужна\n\n  // Важно: Убедитесь, что данные действительно находятся в item.json.\n  // Если title, video_url, choices и т.д. находятся непосредственно в 'item',\n  // то нужно использовать 'const jsonData = item;'\n  const jsonData = item.json;\n\n  if (!jsonData || typeof jsonData !== 'object') {\n    // skippedItemsCount++; // Если статистика нужна\n    continue; // Пропускаем элемент, если нет jsonData или это не объект\n  }\n\n  const title = jsonData.title;\n  const videoUrl = jsonData.video_url;\n  const choices = jsonData.choices;\n  const channelUrl = jsonData.channel_url;\n  const videoId = jsonData.video_id;\n  const userId = jsonData.user_id; // user_id извлекается, но не используется для ключа группировки\n\n  // Проверка на наличие и корректность title и videoUrl для создания ключа\n  if (typeof title !== 'string' || title.trim().length === 0) {\n    // skippedItemsCount++; // Если статистика нужна\n    continue;\n  }\n  if (typeof videoUrl !== 'string' || videoUrl.trim().length === 0) {\n    // skippedItemsCount++; // Если статистика нужна\n    continue;\n  }\n\n  // Создаем комбинированный ключ для уникальной идентификации записи\n  const uniqueKey = `${title}_${videoUrl}`;\n\n  if (!mergedData[uniqueKey]) {\n    mergedData[uniqueKey] = {\n      title: title,\n      video_url: videoUrl,\n      allContents: [],\n      user_id: userId,\n      channel_url: channelUrl,\n      video_id: videoId,\n    };\n  }\n\n  let contentFoundInChoices = false;\n  if (Array.isArray(choices)) {\n    for (const choice of choices) {\n      // Ожидаемая структура: choice.message.content\n      const content = choice?.message?.content;\n\n      if (typeof content === 'string' && content.trim().length > 0) {\n        mergedData[uniqueKey].allContents.push(content.trim());\n        contentFoundInChoices = true;\n      }\n    }\n  }\n\n  // Если текст не найден в 'choices', пытаемся найти его в других распространенных полях.\n  // Адаптируйте этот блок, если ваш текст находится в других специфических полях jsonData.\n  // Например, jsonData.text_content, jsonData.full_text и т.д.\n  if (!contentFoundInChoices) {\n    const alternativeTextSourceFields = [\n        jsonData.description,\n        jsonData.text,\n        jsonData.transcript,\n        jsonData.content, // Еще одно возможное поле\n        // Добавьте сюда другие имена полей, которые могут содержать нужный текст\n    ];\n\n    for (const sourceField of alternativeTextSourceFields) {\n        if (typeof sourceField === 'string' && sourceField.trim().length > 0) {\n            mergedData[uniqueKey].allContents.push(sourceField.trim());\n            // Если текст найден хотя бы в одном альтернативном источнике, можно прекратить поиск\n            // или продолжить, если нужно собрать текст из нескольких полей.\n            // Для данного примера, если нашли, то выходим из цикла по альтернативным полям:\n            break; \n        }\n    }\n  }\n  // Если после всех проверок allContents все еще пуст, значит текст не был найден\n  // в ожидаемых местах для данного uniqueKey.\n  // if (mergedData[uniqueKey].allContents.length === 0) {\n  //   skippedContentCount++; // Если статистика нужна\n  // }\n}\n\nconst outputItems = [];\n\nfor (const key in mergedData) {\n  if (Object.prototype.hasOwnProperty.call(mergedData, key)) {\n    const dataEntry = mergedData[key];\n\n    // Если dataEntry.allContents пуст, mergedChunk будет пустой строкой.\n    // Это ожидаемое поведение, если контент для данного ключа не был найден.\n    const mergedChunk = dataEntry.allContents.join(\"\\n\\n\");\n\n    outputItems.push({\n      json: {\n        title: dataEntry.title,\n        mergedChunk: mergedChunk,\n        user_id: dataEntry.user_id,\n        video_url: dataEntry.video_url,\n        channel_url: dataEntry.channel_url,\n        video_id: dataEntry.video_id,\n      },\n    });\n  }\n}\n\nreturn outputItems;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1920,
        460
      ],
      "id": "bfec6333-4c1e-4d71-bb72-532d3ea47388",
      "name": "Summarizer"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "60d0d292-7f04-40b4-acf3-8a64c13acd26",
              "name": "title",
              "value": "={{ $json['Video Title'] }}",
              "type": "string"
            },
            {
              "id": "753c7ef6-4008-4b16-81f0-7fbe291f015a",
              "name": "video_url",
              "value": "={{ $json['Full Video Link'] }}",
              "type": "string"
            },
            {
              "id": "b51008a2-7ca7-408c-b212-f8a441d7c3e5",
              "name": "video_id",
              "value": "={{ $json['Video ID'] }}",
              "type": "string"
            },
            {
              "id": "79809b76-8c3c-4c95-ab49-6da5319bf6dc",
              "name": "channel_url",
              "value": "={{ $json['Full Channel Link'] }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1780,
        -20
      ],
      "id": "70199767-eeb1-478d-8552-d8a0e41fa1a9",
      "name": "Parse title ulr and publishedAt"
    },
    {
      "parameters": {
        "jsCode": "// Этот код предназначен для узла Code в n8n.\n// Он обрабатывает массив входных элементов (items).\n// Для каждого элемента он проходит по всем свойствам его объекта 'json'.\n// Если свойство является строкой, к нему применяются шаги очистки\n// для удаления форматирования, похожего на JSON.\n\n// Вспомогательная функция для очистки строки\nfunction cleanString(inputString) {\n    // Если входное значение не является строкой, возвращаем его как есть.\n    if (typeof inputString !== 'string') {\n        return inputString;\n    }\n\n    let cleanedJsonString = inputString;\n\n    // --- Шаги очистки ---\n\n    // 1. Удалить потенциальный ведущий маркер 'json' (```json или ``json) и окружающие пробелы/переводы строк.\n    // Флаг 'i' добавлен для нечувствительного к регистру сопоставления 'json'.\n    // (?:```|``) соответствует трем или двум обратным кавычкам.\n    cleanedJsonString = cleanedJsonString.replace(/^\\s*(?:```|``)\\s*json\\s*\\n*/i, '');\n\n    // 2. Удалить потенциальные замыкающие обратные кавычки (``` или ``) и окружающие пробелы/переводы строк.\n    cleanedJsonString = cleanedJsonString.replace(/\\s*(?:```|``)\\s*$/, '');\n\n    // 3. Обрезать все оставшиеся ведущие/конечные пробелы.\n    cleanedJsonString = cleanedJsonString.trim();\n\n    // --- !!! ПРЕДУПРЕЖДЕНИЕ !!! ---\n    // Следующий шаг удаляет критически важные символы структуры JSON: квадратные скобки ([ ]) и фигурные скобки ({ }).\n    // Как указано в исходном описании проблемы, это сделает строку невалидным JSON.\n    // Если следующий узел n8n попытается выполнить JSON.parse() для этого вывода, он ОБЯЗАТЕЛЬНО ВЫДАСТ ОШИБКУ,\n    // если ожидает валидный JSON-объект или массив. Эта логика сохранена согласно вашему исходному заданию.\n    cleanedJsonString = cleanedJsonString.replace(/[\\[\\]\\{\\}]/g, '');\n\n    return cleanedJsonString;\n}\n\n// Обработка каждого элемента во входном массиве 'items'\nconst outputItems = items.map(item => {\n    const newItem = {\n        json: {},\n        // Сохраняем бинарные данные, если они есть\n        ...(item.binary && { binary: item.binary })\n    };\n\n    // Проверяем, существует ли объект item.json\n    if (item.json && typeof item.json === 'object' && item.json !== null) {\n        // Проходим по всем ключам в объекте item.json\n        for (const key in item.json) {\n            if (Object.prototype.hasOwnProperty.call(item.json, key)) {\n                // Применяем функцию очистки к значению свойства\n                newItem.json[key] = cleanString(item.json[key]);\n            }\n        }\n    } else if (item.json) {\n        // Если item.json не является объектом, но существует (например, строка, число),\n        // попробуем обработать его как единственное значение.\n        // Это может потребовать корректировки в зависимости от точной структуры ваших данных.\n        console.warn(`Warning: item.json for an item was not an object. Attempting to clean it directly. Value: ${item.json}`);\n        newItem.json.unknownProcessedValue = cleanString(item.json);\n    }\n\n\n    return newItem;\n});\n\n// --- Вывод ---\n// Возвращаем массив обработанных элементов.\nreturn outputItems;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2160,
        460
      ],
      "id": "dedecf8c-1c5b-4291-961b-0ed911aa2d9a",
      "name": "remove json"
    },
    {
      "parameters": {
        "model": "google/gemma-3-27b-it",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2160,
        820
      ],
      "id": "ab1fe25c-8bf1-43ed-b8f3-3b4805efc1f0",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "xM1Kdr0j4QvJ4iaw",
          "name": "AdminN8N"
        }
      }
    },
    {
      "parameters": {
        "model": "openai/gpt-4.1",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2160,
        1100
      ],
      "id": "a76df112-8e3e-46a8-bd08-90d5d1749980",
      "name": "OpenRouter Chat Model1",
      "credentials": {
        "openRouterApi": {
          "id": "xM1Kdr0j4QvJ4iaw",
          "name": "AdminN8N"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "=Authorization",
              "value": "=Bearer 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"
            },
            {
              "name": "=Content-Type",
              "value": "=application/json"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "application/json",
        "body": "={\n  \"model\": \"google/gemini-2.5-pro-exp-03-25\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You are a translator. Your only task is to take the user’s input and output its English translation — nothing more. Do not add any commentary, explanations, apologies or extra sentences. If the input is already English, return it verbatim.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.transcription[0] }}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.transcription[1] }}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.transcription[2] }}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.transcription[3] }}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.transcription[4] }}\"\n    },\n  ]\n}\n",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2600,
        -440
      ],
      "id": "5133c885-39fd-48dc-9f59-3140fa27ece7",
      "name": "HTTP OpenRouter Request"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        3460,
        -340
      ],
      "id": "e1e918d1-50f4-4974-9427-03d3429352c8",
      "name": "Merge OpenRouter and transcript"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        2420,
        240
      ],
      "id": "4a27ccc2-b9fc-43fe-a4e3-68c4d14abd41",
      "name": "Merge Chunks and title, url, etc"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Generate a lesson theory without bullet points and description what students will be able to..., This project/learning centers/module... Write text like guide, not water AI answer using this materials:\nTitle: {{ $json.title }}\nTopic: {{ $json.topic }}\nDescription: {{ $json.description }}\n\nU need to write 2-3 paragraphs about Description that i gave you\n\nStart output from \"Title: \"{{ $json.title }} \\n\"Lesson Description:\" (each item need \"Title: \" without ## )\n\nDo not add any extra commentary\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        2260,
        740
      ],
      "id": "dd3daf5f-8c75-42cf-8eb9-9c450019938c",
      "name": "Theory Generator"
    },
    {
      "parameters": {
        "jsCode": "// Предполагается, что 'items' - это ваш входной массив.\n// const items = [\n// /* примеры ваших данных:\n// { json: { text: \"\\n\\nTitle: Введение в Python\\nLesson Description:\\nPython это весело.\" } },\n// { json: { text: \"Title: Продвинутый JS\\nLesson Description:\\nJS это мощно.\" } },\n// { json: { text: \"Title: Введение в Python\\nLesson Description:\\nИзучаем переменные.\" } }\n// */\n// ];\n\n// Получаем все входные данные (input items)\nconst inputItems = items; // Замените 'items' на вашу переменную с входными данными\n\n// Объект для хранения описаний, сгруппированных по заголовкам\nconst groupedByTitle = {};\n\ninputItems.forEach(item => {\n    const fullTextFromItem = item.json.processedText;\n\n    // 1. Извлечение заголовка (Title)\n    let title = \"Untitled\"; // Заголовок по умолчанию\n    // Ищем \"Title:\" в начале строки (с учетом многострочности) или просто \"Title:\"\n    const titleMatchStrict = fullTextFromItem.match(/^Title:([^\\n]+)/m);\n    const titleMatchGeneral = fullTextFromItem.match(/Title:([^\\n]+)/);\n\n    if (titleMatchStrict && titleMatchStrict[1]) {\n        title = titleMatchStrict[1].trim();\n    } else if (titleMatchGeneral && titleMatchGeneral[1]) {\n        title = titleMatchGeneral[1].trim();\n    }\n    // Если заголовок не найден, он останется \"Untitled\"\n\n    // 2. Извлечение описания урока (Lesson Description)\n    let description = \"\";\n    const lessonDescMarker = \"Lesson Description:\";\n    const lessonDescStartIndex = fullTextFromItem.indexOf(lessonDescMarker);\n\n    if (lessonDescStartIndex !== -1) {\n        // Извлекаем текст после \"Lesson Description:\" и удаляем лишние пробелы/переводы строк по краям\n        description = fullTextFromItem.substring(lessonDescStartIndex + lessonDescMarker.length).trim();\n    } else {\n        // Если \"Lesson Description:\" не найдено, пытаемся взять текст после строки заголовка (если заголовок был найден)\n        const titlePatternMatch = titleMatchStrict || titleMatchGeneral;\n        if (titlePatternMatch && titlePatternMatch[0]) {\n            const textAfterTitleLine = fullTextFromItem.substring(fullTextFromItem.indexOf(titlePatternMatch[0]) + titlePatternMatch[0].length);\n            description = textAfterTitleLine.trim();\n        } else {\n            // Если ни заголовок, ни маркер описания не найдены,\n            // и текст элемента не пустой, считаем весь текст описанием для \"Untitled\"\n            if (title === \"Untitled\" && fullTextFromItem.trim().length > 0) {\n                description = fullTextFromItem.trim();\n            }\n        }\n    }\n\n    // Добавляем описание в группу, только если оно не пустое\n    if (description) {\n        if (!groupedByTitle[title]) {\n            groupedByTitle[title] = []; // Инициализируем массив для нового заголовка\n        }\n        groupedByTitle[title].push(description);\n    }\n});\n\n// Формируем итоговый массив объединенных данных\nconst mergedResult = [];\nfor (const title in groupedByTitle) {\n    if (groupedByTitle.hasOwnProperty(title)) {\n        const descriptionsArray = groupedByTitle[title];\n        let combinedLessonText = \"\";\n\n        if (descriptionsArray.length > 0) {\n            // Первое описание для данного заголовка\n            // Форматируем в соответствии с исходным требованием пользователя (новая строка перед \"Lesson Description\")\n            combinedLessonText = '\\nLesson Description:\\n' + descriptionsArray[0];\n\n            // Добавляем последующие описания для того же заголовка\n            for (let i = 1; i < descriptionsArray.length; i++) {\n                // Используем две новые строки для визуального разделения между разными блоками описаний\n                combinedLessonText += '\\n\\nLesson Description:\\n' + descriptionsArray[i];\n            }\n        }\n\n        // Собираем финальный текст: Заголовок + объединенные описания\n        let finalOutputText = `Title: ${title}`;\n        if (combinedLessonText) { // Добавляем блок описаний, только если он не пуст\n            finalOutputText += combinedLessonText;\n        }\n\n        mergedResult.push({\n            json: {\n                lessonText: finalOutputText.trim() // Удаляем лишние пробелы по краям всего блока\n            }\n        });\n    }\n}\n\n// Возвращаем объединенные данные\nreturn mergedResult;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2840,
        740
      ],
      "id": "abdb8df6-f653-48cc-a94b-bd5363655014",
      "name": "Theory Merger"
    },
    {
      "parameters": {
        "jsCode": "// --- Начало кода для узла \"Code\" в n8n ---\n\n// Ваша функция для добавления номеров уроков (остается без изменений)\nconst addLessonNumber = (inputText) => {\n  if (typeof inputText !== 'string') {\n    // Эта проверка важна, если поле может быть не строкой\n    // console.warn(\"Входные данные не являются строкой:\", inputText);\n    return inputText; // Возвращаем как есть, если не строка\n  }\n  let lessonCounter = 1;\n  // Заменяем \"Lesson Description:\" на \"Lesson Description X:\"\n  return inputText.replace(/Lesson Description:/g, () => {\n    return `Lesson Description ${lessonCounter++}:`;\n  });\n};\n\n// Получаем все входные элементы (items)\nconst items = $input.all(); // или items = $items в зависимости от настроек/версии\nconst outputItems = []; // Будем собирать сюда обработанные items\n\n// Перебираем каждый элемент (item)\nfor (const item of items) {\n  const newItem = { ...item }; // Создаем копию item, чтобы не изменять оригинал напрямую в цикле (хорошая практика)\n\n  // --- ОТЛАДКА ---\n  // Вы можете добавить эти поля для проверки, что происходит внутри узла\n  // newItem.json.debug_input_lessonText_exists = newItem.json.hasOwnProperty('lessonText');\n  // newItem.json.debug_input_lessonText_value = newItem.json.lessonText;\n  // ---------------\n\n  // Получаем текст из поля lessonText\n  const originalText = newItem.json.lessonText;\n\n  if (originalText && typeof originalText === 'string') {\n    // Применяем вашу функцию\n    const modifiedText = addLessonNumber(originalText);\n    \n    // Сохраняем результат в новое поле ИЛИ перезаписываем старое.\n    // Вариант 1: Сохранить в новое поле (рекомендуется для отладки)\n    newItem.json.processedLessonText = modifiedText;\n    \n    // Вариант 2: Перезаписать оригинальное поле lessonText\n    // newItem.json.lessonText = modifiedText; \n\n    // --- ОТЛАДКА ---\n    // newItem.json.debug_output_modifiedText = modifiedText;\n    // ---------------\n\n  } else {\n    // Если поле lessonText отсутствует, пустое или не строка,\n    // можно просто пропустить обработку или записать в него null/оригинальное значение.\n    // Если вы создавали новое поле processedLessonText:\n    newItem.json.processedLessonText = originalText; // или null, или специальное значение\n    //newItem.json.debug_skipped_processing = true;\n  }\n  \n  outputItems.push(newItem);\n}\n\n// Возвращаем массив обработанных элементов\nreturn outputItems;\n\n// --- Конец кода для узла \"Code\" в n8n ---"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2020,
        980
      ],
      "id": "aad4ee38-5866-4a58-bb74-57c0dc8e641e",
      "name": "Add nums to Lesson Description"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Не пиши коментарии от себя\n\nЯ хочу преобразовать следующий текст в JSON-формат для описания онлайн-курса(курсов, если поступает несколько рядов).\nОбщая информация о курсе:\nНа основе всего предоставленного текста сгенерируй общее название для курса (оно указано в самом начале текста, до Lesson Description).\nНа основе всего предоставленного текста сгенерируй общее описание для курса.\nКатегория курса: 680f332a16f8bb2b6ce9e71d\nУровень сложности: beginner\nИзображение курса: (оставьте пустым)\nПревью изображения курса: (оставьте пустым)\nМодули курса:\nДля каждого блока текста, начинающегося с \"Lesson Description\" и заканчивающегося перед следующим \"Lesson Description\" (или концом текста), создай отдельный модуль в массиве \"modules\".\nДля каждого модуля:\nЗаголовок модуля: Сгенерируй **краткий заголовок**, обобщающий содержание текущего \"Lesson Description\".\nОписание модуля: Сгенерируй **краткое описание**, обобщающее содержание текущего \"Lesson Description\".\nСодержание модуля (\"content\"): Скопируй полностью текст текущего \"Lesson Description\".\nУроки модуля (\"lessons\"): Создай массив, содержащий один объект урока.\nЗаголовок урока (\"title\"): Сформируй заголовок как \"Module №X\", где X - порядковый номер текущего \"Lesson Description\".\nСодержание урока (\"content\"): Скопируй полностью текст текущего \"Lesson Description\", но не только пунктами, должна быть и обычная теория, но должно стать понятным, что надо делать исходя из того что написано\nДлительность урока (\"duration\"): 15\nТип урока (\"type\"): text\nТип контента (\"contentType\"): standard\nРесурсы урока (\"resources\"): []\nПрактические упражнения урока (\"practiceExercises\"): []\nБлоки контента урока (\"contentBlock\"): []\nТесты модуля (\"tests\"): []\nВходной текст:\n{{ $json.processedLessonText }}\nJSON Structure:\n{\n\"title\": \"(Название курса указано в тексте до Lesson Description 1)\",\n\"description\": \"(сгенерированное описание курса)\",\n\"category\": \"680f332a16f8bb2b6ce9e71d\",\n\"difficulty\": \"beginner\",\n\"image\": \"\",\n\"imagePreview\": \"\",\n\"modules\": [\n{\n\"title\": \"(сгенерированный заголовок модуля 1)\",\n\"description\": \"(сгенерированное короткое описание модуля 1)\",\n\"content\": \"(короткий текст Lesson Description 1)\",\n\"lessons\": [\n{\n\"title\": \"Module №1\",\n\"content\": \"(текст Lesson Description 1 переделанный под план, но не только пунктами, должна быть и обычная теория, но должно стать понятным, что надо делать исходя из того что написано)\",\n\"duration\": 15,\n\"type\": \"text\",\n\"contentType\": \"standard\",\n\"resources\": [],\n\"practiceExercises\": [],\n\"contentBlocks\": []\n}\n],\n\"tests\": []\n},\n{\n\"title\": \"(сгенерированный заголовок модуля 2)\",\n\"description\": \"(сгенерированное короткое описание модуля 2)\",\n\"content\": \"(короткий текст Lesson Description 2)\",\n\"lessons\": [\n{\n\"title\": \"Module №2\",\n\"content\": \"(текст Lesson Description 2 переделанный под план что надо делать исходя из того что написано)\",\n\"duration\": 15,\n\"type\": \"text\",\n\"contentType\": \"standard\",\n\"resources\": [],\n\"practiceExercises\": [],\n\"contentBlocks\": []\n}\n],\n\"tests\": []\n},\n// ... и так далее для каждого Lesson Description должен быть сгенерирован модуль\n]\n}\nВажно: Обрати внимание, что общая информация о курсе(курсах) (title, description, category, difficulty, image, imagePreview) указывается только один раз в начале JSON. Массив \"modules\" содержит объекты для каждого \"Lesson Description\". Проверь, чтобы все \",\" и {} были проставлены и Пиши на английском"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        2260,
        1000
      ],
      "id": "359311b5-7f58-4f5c-8f6d-7fa5f546fa6d",
      "name": "JSON generator"
    },
    {
      "parameters": {
        "jsCode": "// Функция для удаления лишних символов из строки\nconst cleanString = (inputText) => {\n  let text = inputText;\n  // Убедимся, что на вход подается именно строка\n  if (typeof text !== 'string') {\n    // Если это не строка, преобразуем ее в строку, чтобы избежать ошибок при дальнейшей обработке.\n    // В зависимости от требований, здесь можно было бы также вернуть пустую строку или ошибку.\n    text = String(text);\n  }\n  return text\n    .replace(/```json\\n/g, '') // Убираем возможное начало блока json-кода, если оно есть\n    .replace(/```/g, '')       // Убираем возможные символы окончания блока кода\n    .replace(/\\n/g, ' ')      // Заменяем все символы переноса строки на пробелы\n    .replace(/\\s+/g, ' ')    // Заменяем последовательности из нескольких пробельных символов на один пробел\n    .trim();                   // Удаляем пробелы в начале и в конце строки\n};\n\n// Инициализируем массив, в который будем собирать все входные элементы для обработки.\nlet allInputItems = [];\n\n// Определяем, каким образом получить все входные элементы.\n// В исходном коде использовался метод $input.first(), что характерно для сред,\n// где $input является специальным объектом-хелпером для доступа к входным данным.\n// В таких средах обычно есть и метод для получения всех элементов.\n\nif (typeof $input.all === 'function') {\n  // Это стандартный способ во многих платформах (например, n8n) для получения массива всех входящих элементов.\n  allInputItems = $input.all();\n} else if (Array.isArray($input)) {\n  // Если переменная $input сама по себе уже является массивом элементов.\n  allInputItems = $input;\n} else if ($input && Array.isArray($input.items)) {\n  // Если элементы хранятся в свойстве 'items' объекта $input (другой распространенный паттерн).\n  allInputItems = $input.items;\n} else if ($input && typeof $input.first === 'function') {\n  // Если есть метод .first(), но нет очевидного стандартного способа получить все элементы (типа .all() или .items).\n  // Это может означать, что платформа не передает все элементы сразу таким образом,\n  // или что код изначально не был рассчитан на пакетную обработку.\n  // Поскольку задача — обработать \"все\" элементы, простое использование .first() здесь будет\n  // некорректным, если элементов на входе больше одного.\n  console.warn(\"Обнаружен метод $input.first(), но не найден стандартный способ получения всех элементов (например, $input.all() или $input.items). Будет предпринята попытка обработать $input как одиночный элемент, если он соответствует ожидаемой структуре.\");\n  // Попытка обработать $input как одиночный элемент, если он имеет структуру item.json.text\n  if ($input && $input.json && typeof $input.json.text === 'string') {\n     allInputItems = [$input]; // Обрабатываем сам $input как массив из одного элемента\n  } else {\n      // Если $input.first() есть, но $input не является одиночным элементом нужной структуры,\n      // и нет $input.all(), то мы не можем надежно получить \"все\" элементы.\n      console.error(\"Не удалось получить все элементы из $input. $input не является массивом, не имеет метода .all() или свойства .items, и сам не является одиночным элементом нужной структуры. Попытка использовать $input.first() как единственный элемент.\");\n      try {\n        const firstItem = $input.first();\n        if (firstItem && firstItem.json && typeof firstItem.json.text === 'string') {\n            allInputItems = [firstItem]; // Обрабатываем только первый, так как другие не найдены\n        } else {\n            allInputItems = []; // Не удалось получить даже первый элемент в нужном формате\n        }\n      } catch(e) {\n        console.error(\"Ошибка при попытке доступа к $input.first() после неудачных попыток получить все элементы:\", e);\n        allInputItems = [];\n      }\n  }\n} else if ($input && $input.json && typeof $input.json.text === 'string') {\n  // Если $input — это сам по себе одиночный элемент (не массив и не хелпер),\n  // но он соответствует ожидаемой структуре { json: { text: \"...\" } }.\n  allInputItems = [$input];\n} else {\n  // Если ни один из известных способов не подошел.\n  console.error(\"Неизвестная структура $input. Не удалось извлечь элементы для обработки. $input:\", $input);\n  allInputItems = []; // Инициализируем пустым массивом, чтобы избежать ошибок далее\n}\n\n// Дополнительная проверка: убедимся, что allInputItems действительно является массивом.\nif (!Array.isArray(allInputItems)) {\n  console.error(\"Переменная allInputItems не является массивом после попыток ее определения. Невозможно обработать элементы. Текущее значение allInputItems:\", allInputItems);\n  // Возвращаем пустой массив, чтобы не прерывать выполнение всего потока ошибкой,\n  // но при этом сигнализируем о проблеме в логах.\n  return [];\n}\n\n// Если массив allInputItems пуст (например, на вход ничего не пришло или не удалось распознать структуру),\n// нет смысла продолжать обработку.\nif (allInputItems.length === 0) {\n    console.log(\"Входные данные для обработки отсутствуют или не были корректно распознаны.\");\n    return []; // Возвращаем пустой массив\n}\n\n// Теперь обрабатываем каждый элемент в полученном массиве allInputItems\nconst results = allInputItems.map((item, index) => {\n  // Проверяем, что текущий 'item' существует, содержит ключ 'json',\n  // и 'item.json' содержит ключ 'text' со строковым значением.\n  // Эта структура должна соответствовать тому, что возвращал $input.first() в вашем оригинальном коде.\n  if (item && item.json && typeof item.json.text === 'string') {\n    const inputString = item.json.text;\n    // Применяем функцию очистки к текстовому содержимому\n    const cleanedString = cleanString(inputString);\n    // Возвращаем объект в требуемом формате\n    return { json: { cleanedText: cleanedString } };\n  } else {\n    // Если элемент имеет неверную структуру или отсутствует необходимое текстовое поле,\n    // логируем это и возвращаем объект с информацией об ошибке.\n    // Это позволяет не прерывать всю обработку из-за одного \"плохого\" элемента.\n    console.warn(`Элемент с индексом ${index} имеет неверную структуру или отсутствует обязательное поле 'item.json.text'. Элемент:`, item);\n    return { json: { error: \"Неверная структура элемента или отсутствует поле 'json.text'\", originalItem: item } };\n  }\n});\n\n// Возвращаем массив обработанных элементов.\n// Каждый элемент этого массива будет объектом вида { json: { cleanedText: \"...\" } }\n// или { json: { error: \"...\", originalItem: ... } } в случае проблем с конкретным элементом.\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2640,
        1000
      ],
      "id": "47ceec2c-daac-4a74-91e9-2132a181b4df",
      "name": "Delete trash"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "da25e488-44b3-4253-b716-f565a6981cd6",
              "leftValue": "={{ $json.joinedText }}",
              "rightValue": "```json",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        660,
        -40
      ],
      "id": "ad954c44-b86a-4d9e-8f60-ffecd4e931eb",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "// Получаем динамический текст из входных данных\nconst inputString = $input.first().json.joinedText;\n\n// Функция для удаления лишних символов\nconst cleanString = (input) => {\n  return input\n    .replace(/```json\\n/g, '') // Убираем начало блока json\n    .replace(/```/g, '') // Убираем окончание блока json\n    .replace(/\\n/g, ' ') // Заменяем все \\n на пробелы\n    .replace(/\\s+/g, ' ') // Убираем лишние пробелы (заменяем несколько пробелов на один)\n    .trim(); // Убираем пробелы в начале и в конце\n};\n\n// Применяем функцию очистки\nconst cleanedString = cleanString(inputString);\n\n// Возвращаем очищенную строку\nreturn [{ json: { cleanedText: cleanedString } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        860,
        -160
      ],
      "id": "2f4417d4-48ea-44cc-a8fd-276c32aa70fa",
      "name": "Delete trash1"
    },
    {
      "parameters": {
        "jsCode": "// items[0].json.cleanedText — это твой JSON в виде строки\nconst raw = items[0].json.cleanedText;\n\n// Если внутри строки используются одинарные кавычки вместо двойных,\n// раскомментируй следующую строку, чтобы привести к валидному JSON:\n// const fixed = raw.replace(/'/g, '\"');\n\n// Парсим строку в массив объектов\nconst arr = JSON.parse(raw /* или fixed */);\n\n// Преобразуем каждый объект в отдельный item n8n\nreturn arr.map(obj => ({\n  json: obj\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1020,
        -200
      ],
      "id": "436e4305-f8b0-44ab-b257-af668ea94877",
      "name": "Code2"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "You are a translator. Your only task is to take the user’s input and output its English translation — nothing more. Do not add any commentary, explanations, apologies or extra sentences. If the input is already English, return it verbatim."
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        3060,
        -440
      ],
      "id": "b036a69f-f8a4-4ee2-89fc-f5f9260ddd1c",
      "name": "Basic LLM Chain"
    },
    {
      "parameters": {
        "model": "google/gemma-3-27b-it",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2880,
        -400
      ],
      "id": "b458b22b-08cd-4205-84e5-e71f87606ca0",
      "name": "OpenRouter Chat Model2",
      "credentials": {
        "openRouterApi": {
          "id": "xM1Kdr0j4QvJ4iaw",
          "name": "AdminN8N"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Find 5 YouTube videos about 'AI Agents scraping or MCP for scrapping web sites' uploaded in 2025. Return video title, video link, and channel link.\n\nPlease provide me output only with extracted information in structured tablesheet format, without \"okay i need, i will give you or something else\""
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        -240,
        220
      ],
      "id": "8a8aa5cf-0583-4df5-b0a2-3322e7841ad7",
      "name": "Basic LLM Chain1"
    },
    {
      "parameters": {
        "model": "openai/gpt-4.1",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -140,
        400
      ],
      "id": "9ec03487-61dd-491c-8c52-ef1a203644c0",
      "name": "OpenRouter Chat Model3",
      "credentials": {
        "openRouterApi": {
          "id": "xM1Kdr0j4QvJ4iaw",
          "name": "AdminN8N"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get the input text from n8n\nconst inputText = $input.first().json.text;\n\n// Split the text by line breaks\nconst rows = inputText.split('\\n');\n\n// Remove the first row if it's empty or contains headers\nrows.shift(); // Removes the first row\n\n// Process each row and shift the columns to the left\nconst processedRows = rows.map(row => {\n    const columns = row.split('|').map(item => item.trim());\n    return {\n        videoTitle: columns[1] || '',  // Map videoTitle to the value of videoLink\n        videoLink: columns[2] || '',   // Map videoLink to the value of channelLink\n        channelLink: ''                // Leave channelLink empty\n    };\n});\n\n// Return the processed rows as output\nreturn processedRows;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        120,
        220
      ],
      "id": "723d9582-be23-4314-a29a-984b84654c5d",
      "name": "Code3"
    },
    {
      "parameters": {
        "jsCode": "const inputText = $input.first().json.joinedText;\n\n// Regex to capture rows and columns from markdown-like table\nconst regex = /^\\|\\s*(.*?)\\s*\\|\\s*(.*?)\\s*\\|\\s*(.*?)\\s*\\|/gm;\n\n// Updated Regex to extract YouTube video ID from various URL formats\n// Handles:\n// - https://youtu.be/ID\n// - https://www.youtube.com/watch?v=ID\n// - https://www.youtube.com/embed/ID\n// - https://www.youtube.com/v/ID\n// - https://www.youtube.com/watch?v=ID&feature=youtu.be (and other params)\nconst videoIdRegex = /(?:youtube\\.com\\/(?:watch\\?.*v=|embed\\/|v\\/)|youtu\\.be\\/)([a-zA-Z0-9_-]+)/;\n\nconst outputItems = [];\nlet match;\n\n// Skip the header and separator line of the table\n// These exec calls advance the regex internal pointer\nlet firstMatch = regex.exec(inputText);  // Header line\nlet secondMatch = regex.exec(inputText); // Separator line (e.g., |---|---|---|)\n\nwhile ((match = regex.exec(inputText)) !== null) {\n    // match[0] is the full matched line (e.g., | Title | Link | Channel |)\n    // match[1] is the content of the first column (Video Title)\n    // match[2] is the content of the second column (Full Video Link)\n    // match[3] is the content of the third column (Full Channel Link)\n\n    const videoTitle = match[1] ? match[1].trim().replace(/\\\\n/g, '') : '';\n    const fullVideoLink = match[2] ? match[2].trim().replace(/\\\\n/g, '') : '';\n    const fullChannelLink = match[3] ? match[3].trim().replace(/\\\\n/g, '') : '';\n\n    // Extract Video ID using the updated videoIdRegex\n    const videoIdMatch = fullVideoLink.match(videoIdRegex);\n    const videoId = videoIdMatch && videoIdMatch[1] ? videoIdMatch[1] : null; // Get the captured group (the ID) or null if no match\n\n    outputItems.push({\n        json: {\n            \"Video Title\": videoTitle,\n            \"Full Video Link\": fullVideoLink,\n            \"Video ID\": videoId, // Added Video ID column\n            \"Full Channel Link\": fullChannelLink\n        }\n    });\n}\n\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1080,
        -20
      ],
      "id": "6d8d7d2e-46d2-416b-b2c6-492267113cbf",
      "name": "Code4"
    },
    {
      "parameters": {
        "url": "https://youtube-transcript3.p.rapidapi.com/api/transcript",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "videoId",
              "value": "={{ $json.video_id }}"
            },
            {
              "name": "Title",
              "value": "={{ $json.title }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "=X-RapidAPI-Host",
              "value": "=youtube-transcript3.p.rapidapi.com"
            },
            {
              "name": "=X-RapidAPI-Key",
              "value": "=4ebd2c4b95mshc8ab3534e42bb1ep1d463fjsn32e3de965ce5"
            }
          ]
        },
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 61000
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2080,
        -180
      ],
      "id": "4382fd79-214f-491f-be13-a01c972f1cb8",
      "name": "youtube video parser1"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        2400,
        -40
      ],
      "id": "b432a153-9396-4db7-863b-9c4c4ece5f5b",
      "name": "Merge transcribation and title, url,  etc"
    },
    {
      "parameters": {
        "jsCode": "// Этот код предназначен для использования в узле \"Code\" в n8n.\n// Входные данные узла доступны в переменной 'items' как массив элементов.\n\n// Мы обработаем каждый входной элемент и добавим новое свойство\n// с объединенным текстом транскрипции ВНУТРИ объекта 'json'.\n\nconst outputItems = items.map(item => {\n  let concatenatedText = '';\n  let transcript = null;\n\n  // Безопасно получаем доступ к массиву транскрипции,\n  // ожидая структуру item.json.transcript.\n  // Используем оператор опциональной последовательности (?.) для безопасного доступа.\n  transcript = item?.json?.transcript;\n\n  // Проверяем, что полученный объект действительно является массивом\n  if (Array.isArray(transcript)) {\n    // Фильтруем записи, которые не являются валидными объектами\n    // или не имеют строкового свойства 'text'.\n    // Затем извлекаем только текст и объединяем его пробелом.\n    const textSegments = transcript\n      .filter(entry => entry && typeof entry === 'object' && typeof entry.text === 'string')\n      .map(entry => entry.text);\n\n    concatenatedText = textSegments.join(' ');\n  } else {\n    // Обрабатываем случаи, когда массив транскрипции отсутствует или не является массивом\n    console.warn(\"Элемент не содержит валидный массив 'json.transcript' или путь к нему:\", item);\n    // В этом случае concatenatedText останется пустой строкой ('').\n    // Вы можете изменить это поведение при необходимости.\n  }\n\n  // Создаем выходной элемент.\n  // Включаем все исходные свойства входного элемента.\n  // Добавляем или модифицируем свойство 'json', чтобы добавить объединенный текст внутрь него.\n  return {\n    ...item, // Копируем все свойства из исходного элемента на верхний уровень\n    json: { // Создаем или обращаемся к объекту 'json'\n      ...(item.json || {}), // Копируем все существующие свойства из item.json (если он есть)\n      concatenatedTranscript: concatenatedText // Добавляем сюда объединенный текст\n    }\n  };\n});\n\n// Узел \"Code\" должен возвращать массив элементов.\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2620,
        -40
      ],
      "id": "4cc6e806-90c5-42e9-89a9-627fb1f6ee8e",
      "name": "Code5"
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "https://docs.google.com/spreadsheets/d/12taRIjIV0oAO9yn1B-LfwZXGAqz4I6mG1zm1UZ3SOUA/edit?usp=sharing",
          "mode": "url"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Part1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/12taRIjIV0oAO9yn1B-LfwZXGAqz4I6mG1zm1UZ3SOUA/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Title": "={{ $json.title }}",
            "Topic and Detail": "={{ $json.mergedChunk }}",
            "UserId": "={{ $json.user_id }}",
            "VideoURL": "={{ $json.video_url }}",
            "ChannelURL": "={{ $json.channel_url }}",
            "VideoID": "={{ $json.video_id }}"
          },
          "matchingColumns": [
            "Title"
          ],
          "schema": [
            {
              "id": "Title",
              "displayName": "Title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Topic and Detail",
              "displayName": "Topic and Detail",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "UserId",
              "displayName": "UserId",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "VideoURL",
              "displayName": "VideoURL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "ChannelURL",
              "displayName": "ChannelURL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "VideoID",
              "displayName": "VideoID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [
        2360,
        460
      ],
      "id": "0616cfee-008b-4edb-84d0-c15cd27212e7",
      "name": "Google Sheets",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "JWf1dYTj83NVJtf5",
          "name": "Google Sheets account 2"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        700,
        840
      ],
      "id": "1c48af5d-085c-4529-b07d-ff9fa59f3eea",
      "name": "When clicking ‘Test workflow’"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "12taRIjIV0oAO9yn1B-LfwZXGAqz4I6mG1zm1UZ3SOUA",
          "mode": "list",
          "cachedResultName": "YoutubePerplexity",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/12taRIjIV0oAO9yn1B-LfwZXGAqz4I6mG1zm1UZ3SOUA/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Part1",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/12taRIjIV0oAO9yn1B-LfwZXGAqz4I6mG1zm1UZ3SOUA/edit#gid=0"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [
        920,
        840
      ],
      "id": "6dff82c1-7115-4015-a2a8-60fe3a6eea51",
      "name": "Google Sheets1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "JWf1dYTj83NVJtf5",
          "name": "Google Sheets account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get all items as an array\nconst allItems = $input.all();\nconst results = [];\n\n// Loop through all items\nfor (let i = 0; i < allItems.length; i++) {\n  const item = allItems[i];\n  const inputJsonString = item.json['Topic and Detail'];\n  const title = item.json.Title;\n  const regex = /\"topic\":\\s*\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"\\s*,\\s*\"detail\":\\s*\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/gs;\n  \n  // Skip items that don't have the required fields\n  if (typeof inputJsonString !== 'string') {\n    console.error(`Error: 'Topic and Detail' is not a string or is undefined for item: ${JSON.stringify(item.json)}`);\n    continue; // Skip this item and continue with the next\n  }\n  \n  let match;\n  while ((match = regex.exec(inputJsonString)) !== null) {\n    // Extract topic and description from regex match\n    const topic = match[1] !== undefined ? match[1].replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\') : \"Error: Topic not found\";\n    const description = match[3] !== undefined ? match[3].replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\') : \"Error: Detail not found\";\n    \n    // Add the processed item to results\n    results.push({\n      Title: title,\n      Topic: topic,\n      Description: description\n    });\n  }\n}\n\n// Return the processed items\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        840
      ],
      "id": "30c22fb0-2f86-41c2-803a-fe24f61ef028",
      "name": "Code6"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        1980,
        1260
      ],
      "id": "c905fceb-b4db-40fb-ba26-fd6459ea6ac3",
      "name": "Merge"
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "https://docs.google.com/spreadsheets/d/12taRIjIV0oAO9yn1B-LfwZXGAqz4I6mG1zm1UZ3SOUA/edit?gid=2099432054#gid=2099432054",
          "mode": "url"
        },
        "sheetName": {
          "__rl": true,
          "value": 2099432054,
          "mode": "list",
          "cachedResultName": "Part2",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/12taRIjIV0oAO9yn1B-LfwZXGAqz4I6mG1zm1UZ3SOUA/edit#gid=2099432054"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Title": "={{ $json.title }}",
            "VideoURL": "={{ $json.video_url }}",
            "ChannelURL": "={{ $json.channel_url }}",
            "VideoID": "={{ $json.video_id }}",
            "json": "={{ $json.cleanedText }}"
          },
          "matchingColumns": [
            "Title"
          ],
          "schema": [
            {
              "id": "Title",
              "displayName": "Title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "VideoURL",
              "displayName": "VideoURL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "ChannelURL",
              "displayName": "ChannelURL",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "VideoID",
              "displayName": "VideoID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "json",
              "displayName": "json",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [
        2200,
        1260
      ],
      "id": "f07fd3da-53c4-4888-a6c4-ad9b47dae4d2",
      "name": "Google Sheets2",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "JWf1dYTj83NVJtf5",
          "name": "Google Sheets account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Обрабатываем входной массив `items`, содержащий объекты с полем mergedChunk (строка с несколькими парами topic/detail)\nconst output = [];\nfor (let i = 0; i < items.length; i++) {\n    const current = items[i].json;\n    const chunk = current.mergedChunk;\n    if (typeof chunk !== 'string') {\n        // Если mergedChunk отсутствует или не является строкой, пропускаем этот элемент\n        continue;\n    }\n\n    // Разбиваем строку на строки по разделителям новой строки\n    const lines = chunk.split(/[\\r\\n]+/);\n    for (let j = 0; j < lines.length; j++) {\n        const topicLine = lines[j].trim();\n        if (topicLine === '') {\n            continue; // пропускаем пустые строки, если есть\n        }\n        if (!topicLine.startsWith('\"topic\":')) {\n            continue; // пропускаем строки, не начинающиеся с \"topic\":\n        }\n        // Проверяем, что следующая строка существует и начинается с \"detail\":\n        if (j + 1 >= lines.length) {\n            break; // достигнут конец без пары \"detail\"\n        }\n        const detailLine = lines[j + 1].trim();\n        if (!detailLine.startsWith('\"detail\":')) {\n            continue; // если по какой-то причине следующая строка не detail, пропускаем\n        }\n\n        // Извлекаем значения topic и detail, убирая префиксы и кавычки с возможной запятой\n        const topicValue = topicLine.replace(/^\"topic\":\\s*\"/, '').replace(/\",?\\s*$/, '');\n        const detailValue = detailLine.replace(/^\"detail\":\\s*\"/, '').replace(/\",?\\s*$/, '');\n\n        // Создаем новый объект с требуемыми полями, копируя поля из текущего элемента и добавляя topic и description\n        output.push({\n            json: {\n                title: current.title,\n                video_url: current.video_url,\n                channel_url: current.channel_url,\n                video_id: current.video_id,\n                topic: topicValue,\n                description: detailValue\n            }\n        });\n\n        j++; // пропускаем следующую строку (detail) в цикле, так как она уже обработана\n    }\n}\n// Возвращаем массив новых объектов\nreturn output;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2020,
        740
      ],
      "id": "0cb4daf3-b78f-4e01-b2ee-898b784f884d",
      "name": "Add Columns"
    },
    {
      "parameters": {
        "jsCode": "// Получаем входные данные\nconst inputItems = $input.all();\n\n// Обрабатываем каждый объект\nconst processedItems = inputItems.map(item => {\n  const inputText = item.json.text;\n  const processedText = inputText.replace(/- \\n\\n.*?Title:/s, 'Title:');\n  return {\n    json: {\n      processedText: processedText\n    }\n  };\n});\n\nreturn processedItems;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2620,
        740
      ],
      "id": "9b707c91-20fe-40c9-b3f0-212c8850abc3",
      "name": "Code1"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "HTTP Request to make.com",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleans text and splits into lines": {
      "main": [
        [
          {
            "node": "Joins lines into single text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request to make.com": {
      "main": [
        [
          {
            "node": "Cleans text and splits into lines",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Joins lines into single text": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Filter": {
      "main": [
        [
          {
            "node": "add transcript_original",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "add transcript_original": {
      "main": [
        []
      ]
    },
    "Chat Completion": {
      "main": [
        [
          {
            "node": "Merge Chunks and title, url, etc",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split to Chunks": {
      "main": [
        [
          {
            "node": "Chat Completion",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Chunks and title, url, etc",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Summarizer": {
      "main": [
        [
          {
            "node": "remove json",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse title ulr and publishedAt": {
      "main": [
        [
          {
            "node": "youtube video parser1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge transcribation and title, url,  etc",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "remove json": {
      "main": [
        [
          {
            "node": "Add Columns",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Theory Generator",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "JSON generator",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "HTTP OpenRouter Request": {
      "main": [
        []
      ]
    },
    "Merge OpenRouter and transcript": {
      "main": [
        []
      ]
    },
    "Merge Chunks and title, url, etc": {
      "main": [
        [
          {
            "node": "Summarizer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Theory Generator": {
      "main": [
        [
          {
            "node": "Code1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Theory Merger": {
      "main": [
        [
          {
            "node": "Add nums to Lesson Description",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add nums to Lesson Description": {
      "main": [
        [
          {
            "node": "JSON generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JSON generator": {
      "main": [
        [
          {
            "node": "Delete trash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        []
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Delete trash1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete trash1": {
      "main": [
        [
          {
            "node": "Code2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code2": {
      "main": [
        []
      ]
    },
    "OpenRouter Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain": {
      "main": [
        [
          {
            "node": "Merge OpenRouter and transcript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain1": {
      "main": [
        [
          {
            "node": "Code3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code4": {
      "main": [
        [
          {
            "node": "Parse title ulr and publishedAt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "youtube video parser1": {
      "main": [
        [
          {
            "node": "Merge transcribation and title, url,  etc",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge transcribation and title, url,  etc": {
      "main": [
        [
          {
            "node": "Code5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code5": {
      "main": [
        [
          {
            "node": "Split to Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‘Test workflow’": {
      "main": [
        [
          {
            "node": "Google Sheets1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Sheets1": {
      "main": [
        [
          {
            "node": "Code6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code6": {
      "main": [
        []
      ]
    },
    "Delete trash": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Google Sheets2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Columns": {
      "main": [
        [
          {
            "node": "Theory Generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code1": {
      "main": [
        [
          {
            "node": "Theory Merger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "270cbe78-3ba3-4fd5-acb2-2b18423312cb",
  "triggerCount": 0,
  "tags": []
}