{
  "createdAt": "2025-05-05T13:31:29.614Z",
  "updatedAt": "2025-05-06T14:56:20.000Z",
  "id": "RoUKvfOsZAN3t7YP",
  "name": "Perplexity + YouTube AI Parser",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "method": "POST",
        "url": "https://hook.eu2.make.com/ha0xladgffsp156aqzplnmlxwx8iq5np",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "message",
              "value": "=Find 5 YouTube videos about 'AI Agents scraping or MCP for scrapping web sites' uploaded in 2025. Return video title, full video link, and full channel link in tablesheet format\n\nPlease provide me output only with extracted information in structured format, without \"okay i need, i will give you or something else\""
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -180,
        -40
      ],
      "id": "66b97695-baf8-42ab-bc1d-bd376a6860e2",
      "name": "HTTP Request to make.com"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {}
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -500,
        -40
      ],
      "id": "d380d7fa-cf63-4f58-997e-b0be1c21aa14",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "jsCode": "function cleanText(inputText) {\n  if (typeof inputText !== 'string') {\n    // В реальной среде автоматизации лучше выбрасывать ошибку\n    // throw new Error(\"Input must be a string.\");\n    console.error(\"Input must be a string.\");\n    return ''; // Возвращаем пустую строку в случае ошибки типа\n  }\n  const thinkTagRegex = /<think>.*?<\\/think>/gs;\n  let cleanedText = inputText.replace(thinkTagRegex, '');\n  const bracketNumberRegex = /\\[\\d+\\]/g;\n  cleanedText = cleanedText.replace(bracketNumberRegex, '');\n  return cleanedText;\n}\n\n/**\n * Cleans the input text and structures the result as an array of objects,\n * where each object represents a non-empty line from the cleaned text.\n * (Без изменений)\n * @param {string} inputText The original string with think tags and bracketed numbers.\n * @returns {Array<object>} An array of objects, e.g., [{ id: 0, lineContent: \"...\" }, ...].\n */\nfunction cleanAndStructureOutput(inputText) {\n  const cleanedFullText = cleanText(inputText);\n  const lines = cleanedFullText.split('\\n');\n  const outputArray = [];\n  let idCounter = 0;\n  for (const line of lines) {\n    const trimmedLine = line.trim();\n    if (trimmedLine !== '') {\n      outputArray.push({\n        id: idCounter++,\n        lineContent: trimmedLine\n      });\n    }\n  }\n  return outputArray;\n}\n\nconst text = $input.first().json.data; // Или $input[0].json.data в стандартном JS\nconst result = cleanAndStructureOutput(text);\nreturn result;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        120,
        -40
      ],
      "id": "113fa118-cc3a-4f49-9e9e-c8b947b84f79",
      "name": "Cleans text and splits into lines"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst joinedText = items.map(item => item.json.lineContent).join('\\n');\nreturn [{ json: { joinedText } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        -40
      ],
      "id": "827187ba-5f46-4042-9e85-824b32a701d1",
      "name": "Joins lines into single text"
    },
    {
      "parameters": {
        "jsCode": "// JavaScript code for n8n to parse YouTube data into a table with three columns\n// Input: $input.first().json.joinedText\n// Output: Array of objects with videoTitle, videoLink, and channelLink\n\nfunction processYoutubeData(inputText) {\n  const result = [];\n  \n  // Split by lines\n  const lines = inputText.split('\\n');\n  \n  // Variables to track data positions\n  let isDataRow = false;\n  let currentTitle = '';\n  let currentVideoLink = '';\n  let currentChannelLink = '';\n  \n  // Process each line\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    \n    // Skip empty lines\n    if (!line) continue;\n    \n    // Check if this is the header line\n    if (line.includes('Video Title') && line.includes('Full Video Link') && line.includes('Full Channel Link')) {\n      isDataRow = true;\n      continue;\n    }\n    \n    // Skip separator lines\n    if (line.includes('----')) {\n      continue;\n    }\n    \n    // If we've found data rows\n    if (isDataRow) {\n      // If the line contains multiple fields separated by '|'\n      if (line.includes('|')) {\n        const parts = line.split('|').map(part => part.trim()).filter(Boolean);\n        \n        // Check if this is the start of a new entry\n        if (parts.length >= 1) {\n          // If we have collected a complete entry before, add it to results\n          if (currentTitle && currentVideoLink) {\n            result.push({\n              videoTitle: currentTitle,\n              videoLink: currentVideoLink,\n              channelLink: currentChannelLink\n            });\n          }\n          \n          // Reset for new entry\n          currentTitle = '';\n          currentVideoLink = '';\n          currentChannelLink = '';\n          \n          // Extract data from parts\n          for (const part of parts) {\n            // Check if part is a video title (no URL)\n            if (!part.includes('http')) {\n              // Skip \"\\\\n\" markers\n              if (part === '\\\\n' || part === '\\n') continue;\n              \n              // If we don't have a title yet, this is the title\n              if (!currentTitle) {\n                currentTitle = part;\n                continue;\n              }\n            }\n            \n            // Check if part is a video link\n            if (part.includes('youtube.com/watch?v=')) {\n              currentVideoLink = part;\n              continue;\n            }\n            \n            // Check if part is a channel link\n            if (part.includes('youtube.com/') && !part.includes('watch?v=')) {\n              currentChannelLink = part;\n              continue;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Add the last entry if there is one\n  if (currentTitle && currentVideoLink) {\n    result.push({\n      videoTitle: currentTitle,\n      videoLink: currentVideoLink,\n      channelLink: currentChannelLink\n    });\n  }\n  \n  return result;\n}\n\n// Main execution for n8n\nconst inputText = $input.first().json.joinedText;\nconst parsedData = processYoutubeData(inputText);\n\n// Return the processed data\nreturn {\n  json: {\n    tableData: parsedData\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        -180
      ],
      "id": "90ab205d-a04b-4da6-8d64-37f0ca0c5c2b",
      "name": "Code"
    },
    {
      "parameters": {
        "jsCode": "// отфильтровать только элементы без ошибки и с определённым transcript\nreturn items.filter(item => {\n  // если есть поле error или transcript === undefined, пропускаем\n  if (item.json.error) return false;\n  if (item.json.transcript === undefined) return false;\n  return true;\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2040,
        -460
      ],
      "id": "3e8756ae-d86b-45b1-bc9f-62b57b8dd0f3",
      "name": "Error Filter"
    },
    {
      "parameters": {
        "jsCode": "// объединим все сегменты transcript в один текст\nconst segs = $json.transcript || [];\nconst fullText = segs.map(s => s.text).join(' ');\n// передадим дальше оригинальные поля + новое\nreturn [{\n  json: {\n    ...$json,\n    transcript_original: fullText\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2300,
        -460
      ],
      "id": "7188bc75-a65b-46e6-a778-d265dd6253b8",
      "name": "add transcript_original"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 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"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "application/json",
        "body": "={{\n  JSON.stringify({\n    model: \"google/gemini-2.5-pro-exp-03-25\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are an instructional designer. Given the user’s transcript text, identify the 4–6 major topics covered and for each provide a concise, detailed description (2–3 sentences). Output the result as a JSON array of objects with the schema [{\\\"topic\\\":\\\"...\\\",\\\"detail\\\":\\\"...\\\"}, …]. Do not add any extra commentary.\"\n      },\n      {\n        role: \"user\",\n        content: $json.chunk\n      }\n    ]\n  })\n}}\n",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 10000
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2160,
        140
      ],
      "id": "1674eb9b-2bee-43b5-86ff-01f8b160d429",
      "name": "Chat Completion"
    },
    {
      "parameters": {
        "jsCode": "// Этот код предназначен для использования в ноде \"Function\" в n8n.\n// Он принимает массив элементов, каждый из которых содержит JSON с полем\n// 'concatenatedTranscript' и метаданными.\n// Код разбивает каждый 'concatenatedTranscript' на более мелкие чанки,\n// стремясь заполнить чанки до maxLen и ища точку разбиения (конец предложения)\n// в \"окне\" перед концом чанка.\n// Метаданные из входного элемента дублируются в каждом выходном чанке\n// с использованием тех же имен полей, что и во входящих:\n// title, video_url, video_id, channel_url.\n\n// Массив для сбора всех результирующих чанков из всех входящих элементов.\n// Каждый элемент этого массива станет отдельным выходным элементом из ноды Function.\nconst outputItems = [];\n\n// Максимальная длина чанка в символах.\nconst maxLen = 3000;\n\n// Размер \"окна\" в символах в конце потенциального чанка,\n// в котором мы будем искать точку разбиения (конец предложения).\nconst splitWindow = 300; // Например, ищем в последних 300 символах перед лимитом\n\n// Проходим по каждому входящему элементу, который поступил в эту ноду.\nfor (const item of items) {\n\n    // --- Извлечение данных из текущего входящего элемента ---\n\n    // Получаем текст для разбивки. Предполагается, что он находится в item.json.concatenatedTranscript.\n    const fullText = item.json.concatenatedTranscript;\n\n    // Получаем метаданные. Используем имена полей, как в ваших примерах ($input.first().json....).\n    // !!! Убедитесь, что эти поля (title, video_url, video_id, channel_url)\n    // !!! точно соответствуют названиям полей в вашем входящем JSON.\n    const { title, video_url, video_id, channel_url } = item.json;\n\n    // --- Обработка и разбиение текста ---\n\n    // Проверяем, существует ли текст для обработки. Если нет, пропускаем этот элемент.\n    if (!fullText) {\n        console.warn('Skipping item with missing or empty concatenatedTranscript:', item);\n        continue; // Переходим к следующему входящему элементу\n    }\n\n    const itemChunksText = []; // Массив для строковых чанков, созданных из *текущего* входящего элемента\n    let currentIndex = 0; // Текущая позиция в исходном тексте\n\n    // Цикл продолжается, пока мы не обработаем весь текст\n    while (currentIndex < fullText.length) {\n\n        // Определяем максимально возможный конец текущего чанка ( currentIndex + maxLen )\n        let potentialChunkEndIndex = Math.min(currentIndex + maxLen, fullText.length);\n\n         // Если оставшийся текст меньше или равен maxLen (с небольшим запасом, чтобы не искать окно в конце),\n        // или мы в конце текста, просто берем весь оставшийся текст как последний чанк.\n        // Добавим условие: если оставшийся текст меньше окна + небольшой буфер, просто берем остаток.\n        if (fullText.length - currentIndex <= splitWindow * 1.5 || potentialChunkEndIndex === fullText.length) {\n             itemChunksText.push(fullText.substring(currentIndex).trim());\n             currentIndex = fullText.length; // Сдвигаем индекс на конец, чтобы выйти из цикла\n             break; // Выходим из цикла обработки текста для текущего элемента\n        }\n\n        // --- Поиск точки разбиения в \"окне\" ---\n\n        // Определяем начало окна для поиска точки разбиения.\n        // Ищем в последних 'splitWindow' символах потенциального чанка,\n        // но не раньше начала текущей позиции (currentIndex).\n        const searchStart = Math.max(currentIndex, potentialChunkEndIndex - splitWindow);\n\n        let bestSplitIndex = -1; // Индекс наилучшей найденной точки разбиения (после символа)\n\n        // Идем назад от конца потенциального чанка к началу окна поиска\n        for (let i = potentialChunkEndIndex - 1; i >= searchStart; i--) {\n            const char = fullText[i];\n\n            // Ищем конец предложения: точка, восклицательный или вопросительный знак\n            if (char === '.' || char === '!' || char === '?') {\n                 // Проверяем, что за знаком препинания следует пробел ИЛИ это конец строки в пределах потенциального чанка\n                 // /\\s/.test(fullText[i + 1]) проверяет, является ли следующий символ пробельным (пробел, табуляция, новая строка)\n                 if (i + 1 < fullText.length && /\\s/.test(fullText[i + 1]) || i + 1 === potentialChunkEndIndex) {\n                     bestSplitIndex = i + 1; // Точка разбиения - сразу ПОСЛЕ знака препинания (и пробела, если есть)\n                     break; // Нашли последнюю подходящую точку в окне, используем ее\n                 }\n            }\n        }\n\n        // --- Определение окончательной точки разбиения чанка ---\n\n        let finalSplitIndex;\n\n        if (bestSplitIndex !== -1) {\n            // Если нашли подходящую точку разбиения в окне, используем ее.\n            // Убедимся, что точка разбиения находится после начала текущего чанка.\n             if (bestSplitIndex > currentIndex) {\n                finalSplitIndex = bestSplitIndex;\n            } else {\n                 // Если bestSplitIndex <= currentIndex, это означает, что ближайшая точка\n                 // препинания с пробелом находится ДО начала текущего чанка или прямо в начале.\n                 // В этом случае делаем разбиение по maxLen как запасной вариант.\n                 finalSplitIndex = potentialChunkEndIndex;\n            }\n\n        } else {\n            // Если не нашли подходящую точку разбиения в окне,\n            // делаем разбиение по maxLen. Это может разорвать предложение.\n            finalSplitIndex = potentialChunkEndIndex;\n        }\n\n        // --- Создание чанка и обновление позиции ---\n\n        // Выделяем текст чанка от текущей позиции до найденной точки разбиения.\n        const chunkText = fullText.substring(currentIndex, finalSplitIndex).trim();\n\n        // Добавляем созданный текстовый чанк в массив чанков текущего элемента, если он не пуст.\n        if (chunkText.length > 0) {\n            itemChunksText.push(chunkText);\n        } else {\n             // Если получился пустой чанк (очень редко, но может быть), сдвигаем currentIndex\n             // хотя бы на 1, чтобы избежать бесконечного цикла.\n             console.warn(`Created an empty chunk for item ${item.id || 'N/A'} starting at index ${currentIndex}. Adjusting index.`);\n             currentIndex++; // Сдвигаем вперед, чтобы не зависнуть\n             continue; // Пропускаем добавление пустого чанка и переходим к следующей итерации\n        }\n\n\n        // Обновляем текущую позицию на конец только что созданного чанка.\n        currentIndex = finalSplitIndex;\n\n        // Пропускаем любые пробелы или символы новой строки сразу после точки разбиения,\n        // чтобы следующий чанк не начинался с них.\n         while (currentIndex < fullText.length && /\\s/.test(fullText[currentIndex])) {\n            currentIndex++;\n        }\n\n\n    } // Конец while цикла для обработки текста одного элемента\n\n\n    // --- Формирование выходных элементов для текущего входящего элемента ---\n\n    // Преобразуем созданные строковые чанки в формат элементов n8n\n    // и добавляем метаданные из текущего входящего элемента К КАЖДОМУ чанку.\n    // Используем имена полей, как в ваших примерах ($input.first().json....).\n    const outputItemChunks = itemChunksText.map(textChunk => {\n        return {\n            json: {\n                chunk: textChunk,       // Сам текст чанка\n                title: title,           // Метаданные: title\n                video_url: video_url,   // Метаданные: video_url\n                video_id: video_id,     // Метаданные: video_id\n                channel_url: channel_url, // Метаданные: channel_url\n                // Если у вас есть другие поля, которые должны дублироваться, добавьте их здесь.\n            },\n        };\n    });\n\n    // Добавляем все созданные для *текущего* входящего элемента чанки\n    // в общий массив результатов, который будет возвращен нодой.\n    outputItems.push(...outputItemChunks);\n\n} // Конец for цикла для обработки всех входящих элементов\n\n// Возвращаем общий массив всех чанков, собранных из всех входных элементов.\n// Каждый элемент в этом массиве станет отдельным выходным элементом из этой ноды.\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1880,
        260
      ],
      "id": "edbab663-9ce6-47a3-b663-cab58130b046",
      "name": "Split to Chunks"
    },
    {
      "parameters": {
        "jsCode": "// Инициализируем пустую строку для сбора текста из всех входных айтемов\nlet allFullText = '';\n\n// Переменные для метаданных, берем их из первого айтема\nlet title, url, publishedAt, videoId;\n\n// Берем метаданные только из первого входного айтема, если он существует\nif (items.length > 0 && items[0].json) {\n  const firstItemJson = items[0].json;\n  title = firstItemJson.title;\n  url = firstItemJson.url;\n  publishedAt = firstItemJson.publishedAt;\n  videoId = firstItemJson.videoId;\n}\n\n\n// Проходим по всем входным айтемам и собираем текст\nfor (const item of items) {\n  // Проверяем, существует ли поле с текстом в текущем айтеме\n  if (item.json && item.json.choices && item.json.choices[0] && item.json.choices[0].message && item.json.choices[0].message.content) {\n    // Добавляем текст текущего айтема к общей строке.\n    // Добавляем перевод строки между текстами разных айтемов для лучшего разделения.\n    allFullText += item.json.choices[0].message.content + '\\n';\n  }\n}\n\n// Максимальная длина чанка (остается прежней)\nconst maxLen = 3000;\n\n// Разбиваем объединенный текст на предложения\n// Учитываем случай, если allFullText пустой\nconst sentences = allFullText.match(/[^\\.!\\?]+[\\.!\\?]+/g) || (allFullText ? [allFullText] : []);\n\n\n// Собираем чанки из объединенных предложений (логика остается прежней)\nlet chunks = [];\nlet current = '';\nfor (const sentence of sentences) {\n  // Убираем лишние пробелы из начала/конца предложения перед проверкой длины\n  const trimmedSentence = sentence.trim();\n  if (!trimmedSentence) continue; // Пропускаем пустые строки после trim\n\n  // Проверяем, поместится ли предложение в текущий чанк\n  // Учитываем пробел, который добавим после предложения\n  if ((current + trimmedSentence).length + (current ? 1 : 0) <= maxLen) {\n    current += trimmedSentence + ' ';\n  } else {\n    // Если текущий чанк не пустой, добавляем его в список чанков\n    if (current) chunks.push(current.trim());\n    // Начинаем новый чанк с текущего предложения\n    current = trimmedSentence + ' ';\n  }\n}\n// Добавляем последний чанк, если он не пустой\nif (current) chunks.push(current.trim());\n\n\n// Преобразуем чанки в выходные айтемы.\n// Метаданные добавляем только к первому чанку общего текста.\nreturn chunks.map((text, idx) => {\n  const base = { summary_points: text };\n  if (idx === 0) {\n    // Только в первом выходном айтеме (первом чанке) добавляем метаданные из первого входного айтема\n    return {\n      json: {\n        ...base,\n        title, // Метаданные из первого входного айтема\n        url,\n        publishedAt,\n        videoId,\n      }\n    };\n  }\n  // Для последующих чанков возвращаем только текст\n  return { json: base };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1920,
        460
      ],
      "id": "bfec6333-4c1e-4d71-bb72-532d3ea47388",
      "name": "Summarizer"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "60d0d292-7f04-40b4-acf3-8a64c13acd26",
              "name": "title",
              "value": "={{ $json['Video Title'] }}",
              "type": "string"
            },
            {
              "id": "753c7ef6-4008-4b16-81f0-7fbe291f015a",
              "name": "video_url",
              "value": "={{ $json['Full Video Link'] }}",
              "type": "string"
            },
            {
              "id": "b51008a2-7ca7-408c-b212-f8a441d7c3e5",
              "name": "video_id",
              "value": "={{ $json['Video ID'] }}",
              "type": "string"
            },
            {
              "id": "79809b76-8c3c-4c95-ab49-6da5319bf6dc",
              "name": "channel_url",
              "value": "={{ $json['Full Channel Link'] }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1780,
        -20
      ],
      "id": "70199767-eeb1-478d-8552-d8a0e41fa1a9",
      "name": "Parse title ulr and publishedAt"
    },
    {
      "parameters": {
        "jsCode": "// Node 1: Clean the raw string containing the JSON array\n\n// Инициализируем переменную для сбора всех частей сырой JSON строки из входных айтемов\nlet combinedRawJsonString = '';\n\n// Переменные для метаданных, берем их из первого входного айтема\nlet title, url;\n\n// Берем метаданные (title, url) только из первого входного айтема, если он существует\nif (items.length > 0 && items[0].json) {\n    const firstInputItemJson = items[0].json;\n    title = firstInputItemJson.title;\n    url = firstInputItemJson.url;\n    // publishedAt и videoId также доступны, но в оригинале не использовались в выходе этого узла.\n}\n\n// Проходим по всем входным айтемам и собираем содержимое поля summary_points\nfor (const item of items) {\n    // Проверяем, существует ли поле summary_points в текущем айтеме\n    if (item.json && item.json.summary_points) {\n        // Добавляем содержимое summary_points текущего айтема к общей строке\n        // Просто конкатенируем, т.к. чистка ниже должна справиться с возможными разрывами\n        combinedRawJsonString += item.json.summary_points;\n    }\n}\n\n// Теперь работаем с объединенной сырой строкой\nlet cleanedJsonString = combinedRawJsonString;\n\n// --- Cleaning Steps ---\n\n// 1. Remove potential leading 'json' marker and surrounding whitespace/newlines.\ncleanedJsonString = cleanedJsonString.replace(/^\\s*```?\\s*json\\s*\\n*/, '');\n\n// 2. Remove potential trailing backticks (``` or `) and surrounding whitespace/newlines.\ncleanedJsonString = cleanedJsonString.replace(/\\s*```?\\s*$/, '');\n\n// 3. Trim any remaining leading/trailing whitespace.\ncleanedJsonString = cleanedJsonString.trim();\n\n// --- !!! WARNING !!! ---\n// The following step removes JSON structure characters ([ ] { }).\n// As noted in the original code, this makes the string invalid JSON and JSON.parse() in the next node WILL FAIL\n// if the next node expects valid JSON. This logic is kept as per your original code.\n\n// 4. Remove square brackets ([ ]) and curly braces ({ }) using a regex\ncleanedJsonString = cleanedJsonString.replace(/[\\[\\]\\{\\}]/g, '');\n\n// --- Prepare Output for the next node ---\n// Мы возвращаем один айтем, содержащий очищенную объединенную строку и метаданные из первого входного айтема.\nreturn [{\n    json: {\n        cleanedJsonString: cleanedJsonString, // Очищенная объединенная строка\n        title: title,                         // Оригинальный title из первого входного айтема\n        url: url                              // Оригинальный URL из первого входного айтема\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2180,
        460
      ],
      "id": "dedecf8c-1c5b-4291-961b-0ed911aa2d9a",
      "name": "remove json"
    },
    {
      "parameters": {
        "model": "google/gemma-3-27b-it",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2800,
        540
      ],
      "id": "ab1fe25c-8bf1-43ed-b8f3-3b4805efc1f0",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "xM1Kdr0j4QvJ4iaw",
          "name": "AdminN8N"
        }
      }
    },
    {
      "parameters": {
        "model": "openai/gpt-4.1",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2800,
        820
      ],
      "id": "a76df112-8e3e-46a8-bd08-90d5d1749980",
      "name": "OpenRouter Chat Model1",
      "credentials": {
        "openRouterApi": {
          "id": "xM1Kdr0j4QvJ4iaw",
          "name": "AdminN8N"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "=Authorization",
              "value": "=Bearer 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"
            },
            {
              "name": "=Content-Type",
              "value": "=application/json"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "application/json",
        "body": "={\n  \"model\": \"google/gemini-2.5-pro-exp-03-25\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You are a translator. Your only task is to take the user’s input and output its English translation — nothing more. Do not add any commentary, explanations, apologies or extra sentences. If the input is already English, return it verbatim.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.transcription[0] }}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.transcription[1] }}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.transcription[2] }}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.transcription[3] }}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.transcription[4] }}\"\n    },\n  ]\n}\n",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2600,
        -440
      ],
      "id": "5133c885-39fd-48dc-9f59-3140fa27ece7",
      "name": "HTTP OpenRouter Request"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        2980,
        -180
      ],
      "id": "e1e918d1-50f4-4974-9427-03d3429352c8",
      "name": "Merge OpenRouter and transcript"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        2420,
        240
      ],
      "id": "4a27ccc2-b9fc-43fe-a4e3-68c4d14abd41",
      "name": "Merge Chunks and title, url, etc"
    },
    {
      "parameters": {
        "jsCode": "// Получаем входные данные\nconst inputData = items;  // Это таблица с колонками Topic, Description и Title\n\n// Массив для хранения результата\nlet result = [];\n\n// Получаем title и url только из первого элемента\nconst title = inputData[0].json.title;\nconst url = inputData[0].json.url;\n\n// Переменная для отслеживания первой строки\nlet isFirstRow = true;\n\n// Проходим по всем строкам и добавляем title и url только для первой строки\ninputData.forEach(item => {\n    // Создаем объект для каждой строки\n    const row = {\n        json: {\n            Topic: item.json.Topic,          // Извлекаем Topic\n            Description: item.json.Description,  // Извлекаем Description\n            title: title  // Дублируем Title из первого элемента\n        }\n    };\n\n    // Добавляем url только для первой строки\n    if (isFirstRow) {\n        row.json.url = url;\n        isFirstRow = false; // После первой строки устанавливаем флаг в false\n    }\n\n    result.push(row);\n});\n\n// Возвращаем результат\nreturn result;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2660,
        460
      ],
      "id": "cdc6cfc2-6225-4127-bf56-eced94fce154",
      "name": "Add Titles to rows"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Generate a lesson theory without bullet points and description what students will be able to..., This project/learning centers/module... Write text like guide, not water AI answer using this materials:\nTitle: {{ $json.title }}\nTopic: {{ $json.Topic }}\nDescription: {{ $json.Description }}\n\nU need to write 2-3 paragraphs about Description that i gave you\n\nStart output from \"Lesson Description:\" \n\nDo not add any extra commentary\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        2900,
        460
      ],
      "id": "dd3daf5f-8c75-42cf-8eb9-9c450019938c",
      "name": "Theory Generator"
    },
    {
      "parameters": {
        "jsCode": "// Получаем все входные данные (input items)\nconst inputItems = items;\n\n// Массив для хранения результата\nlet mergedResult = [];\nlet fullText = '';  // Это будет наш объединенный текст\n\n// Проходим по всем входным данным и собираем текст\ninputItems.forEach(item => {\n    const lessonText = item.json.text;  // Извлекаем текст из каждого input\n\n    // Добавляем разрыв строки перед \"Lesson Description\", если это нужно\n    const formattedText = lessonText.replace(/(Lesson Description)/g, '\\n$1');\n    \n    // Добавляем к полному тексту\n    fullText += formattedText + ' ';\n});\n\n// Формируем итоговый объект\nmergedResult.push({\n    json: {\n        lessonText: fullText.trim()  // Склеиваем все Lesson Description в один блок\n    }\n});\n\n// Возвращаем объединенные данные\nreturn mergedResult;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3280,
        460
      ],
      "id": "abdb8df6-f653-48cc-a94b-bd5363655014",
      "name": "Theory Merger"
    },
    {
      "parameters": {
        "jsCode": "// Получаем динамический текст из входных данных\nconst inputString = $input.first().json.lessonText;\n\n// Функция для добавления числовых индексов перед каждым \"Lesson Description:\"\nconst addLessonNumber = (input) => {\n  let count = 1;\n  // Используем регулярное выражение для поиска всех вхождений \"Lesson Description:\"\n  return input.replace(/(Lesson Description:)/g, () => {\n    return `Lesson Description ${count++}:`;  // Вставляем номер урока перед \"Lesson Description:\"\n  });\n};\n\n// Применяем функцию добавления номеров уроков\nconst updatedString = addLessonNumber(inputString);\n\n// Возвращаем результат\nreturn [{ json: { updatedText: updatedString } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2660,
        700
      ],
      "id": "aad4ee38-5866-4a58-bb74-57c0dc8e641e",
      "name": "Add nums to Lesson Description"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Не пиши коментарии от себя\n\nЯ хочу преобразовать следующий текст в JSON-формат для описания онлайн-курса.\nОбщая информация о курсе:\nНа основе всего предоставленного текста сгенерируй общее название для курса (название не должно быть очень длинным, несколько слов).\nНа основе всего предоставленного текста сгенерируй общее описание для курса.\nКатегория курса: 680f332a16f8bb2b6ce9e71d\nУровень сложности: beginner\nИзображение курса: (оставьте пустым)\nПревью изображения курса: (оставьте пустым)\nМодули курса:\nДля каждого блока текста, начинающегося с \"Lesson Description\" и заканчивающегося перед следующим \"Lesson Description\" (или концом текста), создай отдельный модуль в массиве \"modules\".\nДля каждого модуля:\nЗаголовок модуля: Сгенерируй краткий заголовок, обобщающий содержание текущего \"Lesson Description\".\nОписание модуля: Сгенерируй краткое описание, обобщающее содержание текущего \"Lesson Description\".\nСодержание модуля (\"content\"): Скопируй полностью текст текущего \"Lesson Description\".\nУроки модуля (\"lessons\"): Создай массив, содержащий один объект урока.\nЗаголовок урока (\"title\"): Сформируй заголовок как \"Module №X\", где X - порядковый номер текущего \"Lesson Description\".\nСодержание урока (\"content\"): Скопируй полностью текст текущего \"Lesson Description\".\nДлительность урока (\"duration\"): 15\nТип урока (\"type\"): text\nТип контента (\"contentType\"): standard\nРесурсы урока (\"resources\"): []\nПрактические упражнения урока (\"practiceExercises\"): []\nБлоки контента урока (\"contentBlock\"): []\nТесты модуля (\"tests\"): []\nВходной текст:\n{{ $json.updatedText }}\nJSON Structure:\n{\n\"title\": \"(сгенерированное название курса)\",\n\"description\": \"(сгенерированное описание курса)\",\n\"category\": \"680f332a16f8bb2b6ce9e71d\",\n\"difficulty\": \"beginner\",\n\"image\": \"\",\n\"imagePreview\": \"\",\n\"modules\": [\n{\n\"title\": \"(сгенерированный заголовок модуля 1)\",\n\"description\": \"(сгенерированное описание модуля 1)\",\n\"content\": \"(текст Lesson Description 1)\",\n\"lessons\": [\n{\n\"title\": \"Module №1\",\n\"content\": \"(текст Lesson Description 1)\",\n\"duration\": 15,\n\"type\": \"text\",\n\"contentType\": \"standard\",\n\"resources\": [],\n\"practiceExercises\": [],\n\"contentBlocks\": []\n}\n],\n\"tests\": []\n},\n{\n\"title\": \"(сгенерированный заголовок модуля 2)\",\n\"description\": \"(сгенерированное описание модуля 2)\",\n\"content\": \"(текст Lesson Description 2)\",\n\"lessons\": [\n{\n\"title\": \"Module №2\",\n\"content\": \"(текст Lesson Description 2)\",\n\"duration\": 15,\n\"type\": \"text\",\n\"contentType\": \"standard\",\n\"resources\": [],\n\"practiceExercises\": [],\n\"contentBlocks\": []\n}\n],\n\"tests\": []\n},\n// ... и так далее для каждого Lesson Description должен быть сгенерирован модуль\n]\n}\nВажно: Обрати внимание, что общая информация о курсе (title, description, category, difficulty, image, imagePreview) указывается только один раз в начале JSON. Массив \"modules\" содержит объекты для каждого \"Lesson Description\". и Пиши на английском"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        2900,
        720
      ],
      "id": "359311b5-7f58-4f5c-8f6d-7fa5f546fa6d",
      "name": "JSON generator"
    },
    {
      "parameters": {
        "jsCode": "// Получаем динамический текст из входных данных\nconst inputString = $input.first().json.text;\n\n// Функция для удаления лишних символов\nconst cleanString = (input) => {\n  return input\n    .replace(/```json\\n/g, '') // Убираем начало блока json\n    .replace(/```/g, '') // Убираем окончание блока json\n    .replace(/\\n/g, ' ') // Заменяем все \\n на пробелы\n    .replace(/\\s+/g, ' ') // Убираем лишние пробелы (заменяем несколько пробелов на один)\n    .trim(); // Убираем пробелы в начале и в конце\n};\n\n// Применяем функцию очистки\nconst cleanedString = cleanString(inputString);\n\n// Возвращаем очищенную строку\nreturn [{ json: { cleanedText: cleanedString } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3280,
        720
      ],
      "id": "47ceec2c-daac-4a74-91e9-2132a181b4df",
      "name": "Delete trash"
    },
    {
      "parameters": {
        "jsCode": "// Получаем очищенную строку из предыдущего узла\nconst cleanedJsonString = items[0].json.cleanedJsonString;\n\n// Шаблон для парсинга — регулярное выражение для извлечения topic и detail\nconst regex = /\"topic\":\\s*\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"\\s*,\\s*\"detail\":\\s*\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/gs;\n\n// Массив для хранения результата\nlet result = [];\nlet match;\n\n// Извлекаем метаданные из первого элемента\nconst title = items[0].json.title;\nconst url = items[0].json.url;\n\n// Проходим по строкам и извлекаем значения для topic и description\nlet isFirstRow = true; // Переменная для отслеживания первой строки\nwhile ((match = regex.exec(cleanedJsonString)) !== null) {\n    // match[1] содержит значение 'topic'\n    // match[3] содержит значение 'detail'\n    let row = {\n        json: {\n            Topic: match[1],       // Тема\n            Description: match[3]  // Описание\n        }\n    };\n\n    // Добавляем title и url только для первой строки\n    if (isFirstRow) {\n        row.json.title = title;\n        row.json.url = url;\n        isFirstRow = false; // После первой строки устанавливаем флаг в false\n    }\n\n    result.push(row);\n}\n\n// Возвращаем результат в формате, где каждая строка представляет собой объект с Topic, Description, title и url (для первой строки)\nreturn result;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        460
      ],
      "id": "873853ac-dea9-4b4f-9dfb-3c36da8c1257",
      "name": "Code1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "da25e488-44b3-4253-b716-f565a6981cd6",
              "leftValue": "={{ $json.joinedText }}",
              "rightValue": "```json",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        660,
        -40
      ],
      "id": "ad954c44-b86a-4d9e-8f60-ffecd4e931eb",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "// Получаем динамический текст из входных данных\nconst inputString = $input.first().json.joinedText;\n\n// Функция для удаления лишних символов\nconst cleanString = (input) => {\n  return input\n    .replace(/```json\\n/g, '') // Убираем начало блока json\n    .replace(/```/g, '') // Убираем окончание блока json\n    .replace(/\\n/g, ' ') // Заменяем все \\n на пробелы\n    .replace(/\\s+/g, ' ') // Убираем лишние пробелы (заменяем несколько пробелов на один)\n    .trim(); // Убираем пробелы в начале и в конце\n};\n\n// Применяем функцию очистки\nconst cleanedString = cleanString(inputString);\n\n// Возвращаем очищенную строку\nreturn [{ json: { cleanedText: cleanedString } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        860,
        -160
      ],
      "id": "2f4417d4-48ea-44cc-a8fd-276c32aa70fa",
      "name": "Delete trash1"
    },
    {
      "parameters": {
        "jsCode": "// items[0].json.cleanedText — это твой JSON в виде строки\nconst raw = items[0].json.cleanedText;\n\n// Если внутри строки используются одинарные кавычки вместо двойных,\n// раскомментируй следующую строку, чтобы привести к валидному JSON:\n// const fixed = raw.replace(/'/g, '\"');\n\n// Парсим строку в массив объектов\nconst arr = JSON.parse(raw /* или fixed */);\n\n// Преобразуем каждый объект в отдельный item n8n\nreturn arr.map(obj => ({\n  json: obj\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1020,
        -200
      ],
      "id": "436e4305-f8b0-44ab-b257-af668ea94877",
      "name": "Code2"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "You are a translator. Your only task is to take the user’s input and output its English translation — nothing more. Do not add any commentary, explanations, apologies or extra sentences. If the input is already English, return it verbatim."
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        2580,
        -220
      ],
      "id": "b036a69f-f8a4-4ee2-89fc-f5f9260ddd1c",
      "name": "Basic LLM Chain"
    },
    {
      "parameters": {
        "model": "google/gemma-3-27b-it",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2400,
        -240
      ],
      "id": "b458b22b-08cd-4205-84e5-e71f87606ca0",
      "name": "OpenRouter Chat Model2",
      "credentials": {
        "openRouterApi": {
          "id": "xM1Kdr0j4QvJ4iaw",
          "name": "AdminN8N"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Find 5 YouTube videos about 'AI Agents scraping or MCP for scrapping web sites' uploaded in 2025. Return video title, video link, and channel link.\n\nPlease provide me output only with extracted information in structured tablesheet format, without \"okay i need, i will give you or something else\""
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        -240,
        220
      ],
      "id": "8a8aa5cf-0583-4df5-b0a2-3322e7841ad7",
      "name": "Basic LLM Chain1"
    },
    {
      "parameters": {
        "model": "openai/gpt-4.1",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -140,
        400
      ],
      "id": "9ec03487-61dd-491c-8c52-ef1a203644c0",
      "name": "OpenRouter Chat Model3",
      "credentials": {
        "openRouterApi": {
          "id": "xM1Kdr0j4QvJ4iaw",
          "name": "AdminN8N"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get the input text from n8n\nconst inputText = $input.first().json.text;\n\n// Split the text by line breaks\nconst rows = inputText.split('\\n');\n\n// Remove the first row if it's empty or contains headers\nrows.shift(); // Removes the first row\n\n// Process each row and shift the columns to the left\nconst processedRows = rows.map(row => {\n    const columns = row.split('|').map(item => item.trim());\n    return {\n        videoTitle: columns[1] || '',  // Map videoTitle to the value of videoLink\n        videoLink: columns[2] || '',   // Map videoLink to the value of channelLink\n        channelLink: ''                // Leave channelLink empty\n    };\n});\n\n// Return the processed rows as output\nreturn processedRows;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        120,
        220
      ],
      "id": "723d9582-be23-4314-a29a-984b84654c5d",
      "name": "Code3"
    },
    {
      "parameters": {
        "jsCode": "const inputText = $input.first().json.joinedText;\n\n// Regex to capture rows and columns\nconst regex = /^\\|\\s*(.*?)\\s*\\|\\s*(.*?)\\s*\\|\\s*(.*?)\\s*\\|/gm;\n\n// Regex to extract YouTube video ID from URL\nconst videoIdRegex = /[?&]v=([a-zA-Z0-9_-]+)/;\n\nconst outputItems = [];\nlet match;\n\n// Skip the header and separator line\nlet firstMatch = regex.exec(inputText);\nlet secondMatch = regex.exec(inputText);\n\n\nwhile ((match = regex.exec(inputText)) !== null) {\n    const videoTitle = match[1].trim().replace(/\\\\n/g, '');\n    const fullVideoLink = match[2].trim().replace(/\\\\n/g, '');\n    const fullChannelLink = match[3].trim().replace(/\\\\n/g, '');\n\n    // Extract Video ID using the videoIdRegex\n    const videoIdMatch = fullVideoLink.match(videoIdRegex);\n    const videoId = videoIdMatch && videoIdMatch[1] ? videoIdMatch[1] : null; // Get the captured group or null if no match\n\n    outputItems.push({\n        json: {\n            \"Video Title\": videoTitle,\n            \"Full Video Link\": fullVideoLink,\n            \"Video ID\": videoId, // Added Video ID column\n            \"Full Channel Link\": fullChannelLink\n        }\n    });\n}\n\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1080,
        -20
      ],
      "id": "6d8d7d2e-46d2-416b-b2c6-492267113cbf",
      "name": "Code4"
    },
    {
      "parameters": {
        "url": "https://youtube-transcript3.p.rapidapi.com/api/transcript",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "videoId",
              "value": "={{ $json.video_id }}"
            },
            {
              "name": "Title",
              "value": "={{ $json.title }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "=X-RapidAPI-Host",
              "value": "=youtube-transcript3.p.rapidapi.com"
            },
            {
              "name": "=X-RapidAPI-Key",
              "value": "=4ebd2c4b95mshc8ab3534e42bb1ep1d463fjsn32e3de965ce5"
            }
          ]
        },
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 100000
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2080,
        -180
      ],
      "id": "4382fd79-214f-491f-be13-a01c972f1cb8",
      "name": "youtube video parser1"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        2400,
        -40
      ],
      "id": "b432a153-9396-4db7-863b-9c4c4ece5f5b",
      "name": "Merge transcribation and title, url,  etc"
    },
    {
      "parameters": {
        "jsCode": "// Этот код предназначен для использования в узле \"Code\" в n8n.\n// Входные данные узла доступны в переменной 'items' как массив элементов.\n\n// Мы обработаем каждый входной элемент и добавим новое свойство\n// с объединенным текстом транскрипции ВНУТРИ объекта 'json'.\n\nconst outputItems = items.map(item => {\n  let concatenatedText = '';\n  let transcript = null;\n\n  // Безопасно получаем доступ к массиву транскрипции,\n  // ожидая структуру item.json.transcript.\n  // Используем оператор опциональной последовательности (?.) для безопасного доступа.\n  transcript = item?.json?.transcript;\n\n  // Проверяем, что полученный объект действительно является массивом\n  if (Array.isArray(transcript)) {\n    // Фильтруем записи, которые не являются валидными объектами\n    // или не имеют строкового свойства 'text'.\n    // Затем извлекаем только текст и объединяем его пробелом.\n    const textSegments = transcript\n      .filter(entry => entry && typeof entry === 'object' && typeof entry.text === 'string')\n      .map(entry => entry.text);\n\n    concatenatedText = textSegments.join(' ');\n  } else {\n    // Обрабатываем случаи, когда массив транскрипции отсутствует или не является массивом\n    console.warn(\"Элемент не содержит валидный массив 'json.transcript' или путь к нему:\", item);\n    // В этом случае concatenatedText останется пустой строкой ('').\n    // Вы можете изменить это поведение при необходимости.\n  }\n\n  // Создаем выходной элемент.\n  // Включаем все исходные свойства входного элемента.\n  // Добавляем или модифицируем свойство 'json', чтобы добавить объединенный текст внутрь него.\n  return {\n    ...item, // Копируем все свойства из исходного элемента на верхний уровень\n    json: { // Создаем или обращаемся к объекту 'json'\n      ...(item.json || {}), // Копируем все существующие свойства из item.json (если он есть)\n      concatenatedTranscript: concatenatedText // Добавляем сюда объединенный текст\n    }\n  };\n});\n\n// Узел \"Code\" должен возвращать массив элементов.\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2620,
        -40
      ],
      "id": "4cc6e806-90c5-42e9-89a9-627fb1f6ee8e",
      "name": "Code5"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "HTTP Request to make.com",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleans text and splits into lines": {
      "main": [
        [
          {
            "node": "Joins lines into single text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request to make.com": {
      "main": [
        [
          {
            "node": "Cleans text and splits into lines",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Joins lines into single text": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Filter": {
      "main": [
        [
          {
            "node": "add transcript_original",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "add transcript_original": {
      "main": [
        []
      ]
    },
    "Chat Completion": {
      "main": [
        [
          {
            "node": "Merge Chunks and title, url, etc",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split to Chunks": {
      "main": [
        [
          {
            "node": "Chat Completion",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Chunks and title, url, etc",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Summarizer": {
      "main": [
        [
          {
            "node": "remove json",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse title ulr and publishedAt": {
      "main": [
        [
          {
            "node": "youtube video parser1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge transcribation and title, url,  etc",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "remove json": {
      "main": [
        [
          {
            "node": "Code1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Theory Generator",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "JSON generator",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "HTTP OpenRouter Request": {
      "main": [
        []
      ]
    },
    "Merge OpenRouter and transcript": {
      "main": [
        []
      ]
    },
    "Merge Chunks and title, url, etc": {
      "main": [
        [
          {
            "node": "Summarizer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Titles to rows": {
      "main": [
        [
          {
            "node": "Theory Generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Theory Generator": {
      "main": [
        [
          {
            "node": "Theory Merger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Theory Merger": {
      "main": [
        [
          {
            "node": "Add nums to Lesson Description",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add nums to Lesson Description": {
      "main": [
        [
          {
            "node": "JSON generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JSON generator": {
      "main": [
        [
          {
            "node": "Delete trash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code1": {
      "main": [
        [
          {
            "node": "Add Titles to rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        []
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Delete trash1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete trash1": {
      "main": [
        [
          {
            "node": "Code2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code2": {
      "main": [
        []
      ]
    },
    "OpenRouter Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain": {
      "main": [
        [
          {
            "node": "Merge OpenRouter and transcript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain1": {
      "main": [
        [
          {
            "node": "Code3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code4": {
      "main": [
        [
          {
            "node": "Parse title ulr and publishedAt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "youtube video parser1": {
      "main": [
        [
          {
            "node": "Merge transcribation and title, url,  etc",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge transcribation and title, url,  etc": {
      "main": [
        [
          {
            "node": "Code5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code5": {
      "main": [
        [
          {
            "node": "Split to Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "fbd9f3b4-5d10-442a-b155-4558764137db",
  "triggerCount": 0,
  "tags": []
}