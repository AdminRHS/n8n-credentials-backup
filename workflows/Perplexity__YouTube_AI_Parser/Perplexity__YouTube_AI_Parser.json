{
  "createdAt": "2025-05-05T13:31:29.614Z",
  "updatedAt": "2025-05-05T14:33:22.000Z",
  "id": "RoUKvfOsZAN3t7YP",
  "name": "Perplexity + YouTube AI Parser",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "method": "POST",
        "url": "https://hook.eu2.make.com/ha0xladgffsp156aqzplnmlxwx8iq5np",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "message",
              "value": "=Find 5 YouTube videos about 'scraping' uploaded in 2025. Return video title, video link, and channel link.\n\nPlease provide me output only with extracted information in structured format, without \"okay i need, i will give you or something else\""
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -180,
        -40
      ],
      "id": "66b97695-baf8-42ab-bc1d-bd376a6860e2",
      "name": "HTTP Request to make.com"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {}
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -500,
        -40
      ],
      "id": "d380d7fa-cf63-4f58-997e-b0be1c21aa14",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "jsCode": "function cleanText(inputText) {\n  if (typeof inputText !== 'string') {\n    // В реальной среде автоматизации лучше выбрасывать ошибку\n    // throw new Error(\"Input must be a string.\");\n    console.error(\"Input must be a string.\");\n    return ''; // Возвращаем пустую строку в случае ошибки типа\n  }\n  const thinkTagRegex = /<think>.*?<\\/think>/gs;\n  let cleanedText = inputText.replace(thinkTagRegex, '');\n  const bracketNumberRegex = /\\[\\d+\\]/g;\n  cleanedText = cleanedText.replace(bracketNumberRegex, '');\n  return cleanedText;\n}\n\n/**\n * Cleans the input text and structures the result as an array of objects,\n * where each object represents a non-empty line from the cleaned text.\n * (Без изменений)\n * @param {string} inputText The original string with think tags and bracketed numbers.\n * @returns {Array<object>} An array of objects, e.g., [{ id: 0, lineContent: \"...\" }, ...].\n */\nfunction cleanAndStructureOutput(inputText) {\n  const cleanedFullText = cleanText(inputText);\n  const lines = cleanedFullText.split('\\n');\n  const outputArray = [];\n  let idCounter = 0;\n  for (const line of lines) {\n    const trimmedLine = line.trim();\n    if (trimmedLine !== '') {\n      outputArray.push({\n        id: idCounter++,\n        lineContent: trimmedLine\n      });\n    }\n  }\n  return outputArray;\n}\n\nconst text = $input.first().json.data; // Или $input[0].json.data в стандартном JS\nconst result = cleanAndStructureOutput(text);\nreturn result;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        120,
        -40
      ],
      "id": "113fa118-cc3a-4f49-9e9e-c8b947b84f79",
      "name": "Cleans text and splits into lines"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst joinedText = items.map(item => item.json.lineContent).join('\\n');\nreturn [{ json: { joinedText } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        440,
        -40
      ],
      "id": "827187ba-5f46-4042-9e85-824b32a701d1",
      "name": "Joins lines into single text"
    },
    {
      "parameters": {
        "jsCode": "// исходный текст\nconst text = items[0].json.joinedText;\n\n// разбиваем на реальные строки таблицы (каждая начинается с '|')\nconst lines = text\n  .split(/\\r?\\n(?=\\|)/)         // только там, где после \\n идёт |\n  .map(l => l.trim())\n  .filter(l => \n    l.startsWith('|') &&        // только строки таблицы\n    !l.startsWith('|-') &&      // пропускаем разделитель\n    !l.includes('Video Title')  // пропускаем шапку\n  );\n\n// превращаем каждую строку в массив ячеек\nconst rows = lines.map(l =>\n  l\n    .replace(/^\\||\\|$/g, '')     // убрать первый и последний '|'\n    .split('|')                  // разбить на ячейки\n    .map(c => c.trim())          // обрезать пробелы\n);\n\n// функция для извлечения URL из Markdown [текст](url)\nfunction extractUrl(md) {\n  const m = md.match(/\\((https?:\\/\\/[^)]+)\\)/);\n  return m ? m[1] : '';\n}\n\nreturn rows\n  .filter(cols => cols.length >= 3)   // минимум три колонки\n  .map(cols => {\n    // последние две ячейки – это всегда видео и канал\n    const channelMd = cols.pop();\n    const videoMd   = cols.pop();\n    // всё, что осталось слева – части названия\n    const title     = cols.join(' | ');\n    return {\n      json: {\n        video_title: title,\n        video_link:   extractUrl(videoMd),\n        channel_link: extractUrl(channelMd),\n      }\n    };\n  });\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1020,
        -20
      ],
      "id": "90ab205d-a04b-4da6-8d64-37f0ca0c5c2b",
      "name": "Code"
    },
    {
      "parameters": {
        "jsCode": "// отфильтровать только элементы без ошибки и с определённым transcript\nreturn items.filter(item => {\n  // если есть поле error или transcript === undefined, пропускаем\n  if (item.json.error) return false;\n  if (item.json.transcript === undefined) return false;\n  return true;\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2440,
        -40
      ],
      "id": "3e8756ae-d86b-45b1-bc9f-62b57b8dd0f3",
      "name": "Error Filter"
    },
    {
      "parameters": {
        "url": "https://youtube-transcript3.p.rapidapi.com/api/transcript",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "videoId",
              "value": "={{ $json.video_url }}"
            },
            {
              "name": "Title",
              "value": "={{ $json.title }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "=X-RapidAPI-Host",
              "value": "=youtube-transcript3.p.rapidapi.com"
            },
            {
              "name": "=X-RapidAPI-Key",
              "value": "=f7f02f04f5mshc37f3e7eedb6f29p111f4djsn60e622f16916"
            }
          ]
        },
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 100000
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1940,
        -160
      ],
      "id": "fb41dec2-df1a-4e3c-b5a8-865ac71ca08d",
      "name": "youtube video parser"
    },
    {
      "parameters": {
        "jsCode": "// объединим все сегменты transcript в один текст\nconst segs = $json.transcript || [];\nconst fullText = segs.map(s => s.text).join(' ');\n// передадим дальше оригинальные поля + новое\nreturn [{\n  json: {\n    ...$json,\n    transcript_original: fullText\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1700,
        280
      ],
      "id": "7188bc75-a65b-46e6-a778-d265dd6253b8",
      "name": "add transcript_original"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer 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"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "application/json",
        "body": "={{\n  JSON.stringify({\n    model: \"google/gemini-2.5-pro-exp-03-25\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are an instructional designer. Given the user’s transcript text, identify the 4–6 major topics covered and for each provide a concise, detailed description (2–3 sentences). Output the result as a JSON array of objects with the schema [{\\\"topic\\\":\\\"...\\\",\\\"detail\\\":\\\"...\\\"}, …]. Do not add any extra commentary.\"\n      },\n      {\n        role: \"user\",\n        content: $json.chunk\n      }\n    ]\n  })\n}}\n",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1,
              "batchInterval": 10000
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2720,
        100
      ],
      "id": "1674eb9b-2bee-43b5-86ff-01f8b160d429",
      "name": "Chat Completion"
    },
    {
      "parameters": {
        "jsCode": "// Берём исходный текст и метаданные из первого элемента\nconst input = items[0].json;\nconst fullText = input.choices[0].message.content;\nconst { title, url, publishedAt, videoId } = input;\n\n// Максимальная длина чанка\nconst maxLen = 3000;\n\n// Разбиваем на массив предложений (учитываем точки, воскл. и вопросит. знаки)\nconst sentences = fullText.match(/[^\\.!\\?]+[\\.!\\?]+/g) || [fullText];\n\n// Накопитель\nlet chunks = [];\nlet current = '';\n\n// Проходим по каждому предложению\nfor (const sentence of sentences) {\n  if ((current + sentence).length <= maxLen) {\n    current += sentence + ' ';\n  } else {\n    if (current) chunks.push(current.trim());\n    current = sentence + ' ';\n  }\n}\n// Последний чанк\nif (current) chunks.push(current.trim());\n\n// Преобразуем в items, добавляя метаданные только в первый\nreturn chunks.map((textChunk, index) => {\n  const base = { chunk: textChunk };\n  if (index === 0) {\n    // добавляем поля только для первого элемента\n    return {\n      json: {\n        ...base,\n        title,\n        url,\n        publishedAt,\n        videoId,\n      },\n    };\n  }\n  // последующие — только chunk\n  return { json: base };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2440,
        260
      ],
      "id": "edbab663-9ce6-47a3-b663-cab58130b046",
      "name": "Split to Chunks"
    },
    {
      "parameters": {
        "jsCode": "// Инициализируем пустую строку для сбора текста из всех входных айтемов\nlet allFullText = '';\n\n// Переменные для метаданных, берем их из первого айтема\nlet title, url, publishedAt, videoId;\n\n// Берем метаданные только из первого входного айтема, если он существует\nif (items.length > 0 && items[0].json) {\n  const firstItemJson = items[0].json;\n  title = firstItemJson.title;\n  url = firstItemJson.url;\n  publishedAt = firstItemJson.publishedAt;\n  videoId = firstItemJson.videoId;\n}\n\n\n// Проходим по всем входным айтемам и собираем текст\nfor (const item of items) {\n  // Проверяем, существует ли поле с текстом в текущем айтеме\n  if (item.json && item.json.choices && item.json.choices[0] && item.json.choices[0].message && item.json.choices[0].message.content) {\n    // Добавляем текст текущего айтема к общей строке.\n    // Добавляем перевод строки между текстами разных айтемов для лучшего разделения.\n    allFullText += item.json.choices[0].message.content + '\\n';\n  }\n}\n\n// Максимальная длина чанка (остается прежней)\nconst maxLen = 3000;\n\n// Разбиваем объединенный текст на предложения\n// Учитываем случай, если allFullText пустой\nconst sentences = allFullText.match(/[^\\.!\\?]+[\\.!\\?]+/g) || (allFullText ? [allFullText] : []);\n\n\n// Собираем чанки из объединенных предложений (логика остается прежней)\nlet chunks = [];\nlet current = '';\nfor (const sentence of sentences) {\n  // Убираем лишние пробелы из начала/конца предложения перед проверкой длины\n  const trimmedSentence = sentence.trim();\n  if (!trimmedSentence) continue; // Пропускаем пустые строки после trim\n\n  // Проверяем, поместится ли предложение в текущий чанк\n  // Учитываем пробел, который добавим после предложения\n  if ((current + trimmedSentence).length + (current ? 1 : 0) <= maxLen) {\n    current += trimmedSentence + ' ';\n  } else {\n    // Если текущий чанк не пустой, добавляем его в список чанков\n    if (current) chunks.push(current.trim());\n    // Начинаем новый чанк с текущего предложения\n    current = trimmedSentence + ' ';\n  }\n}\n// Добавляем последний чанк, если он не пустой\nif (current) chunks.push(current.trim());\n\n\n// Преобразуем чанки в выходные айтемы.\n// Метаданные добавляем только к первому чанку общего текста.\nreturn chunks.map((text, idx) => {\n  const base = { summary_points: text };\n  if (idx === 0) {\n    // Только в первом выходном айтеме (первом чанке) добавляем метаданные из первого входного айтема\n    return {\n      json: {\n        ...base,\n        title, // Метаданные из первого входного айтема\n        url,\n        publishedAt,\n        videoId,\n      }\n    };\n  }\n  // Для последующих чанков возвращаем только текст\n  return { json: base };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1700,
        460
      ],
      "id": "bfec6333-4c1e-4d71-bb72-532d3ea47388",
      "name": "Summarizer"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "60d0d292-7f04-40b4-acf3-8a64c13acd26",
              "name": "title",
              "value": "={{ $json.video_title }}",
              "type": "string"
            },
            {
              "id": "753c7ef6-4008-4b16-81f0-7fbe291f015a",
              "name": "video_url",
              "value": "={{ $json.video_link }}",
              "type": "string"
            },
            {
              "id": "b51008a2-7ca7-408c-b212-f8a441d7c3e5",
              "name": "channel_url",
              "value": "={{ $json.channel_link }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1700,
        -20
      ],
      "id": "70199767-eeb1-478d-8552-d8a0e41fa1a9",
      "name": "Parse title ulr and publishedAt"
    },
    {
      "parameters": {
        "jsCode": "// Node 1: Clean the raw string containing the JSON array\n\n// Инициализируем переменную для сбора всех частей сырой JSON строки из входных айтемов\nlet combinedRawJsonString = '';\n\n// Переменные для метаданных, берем их из первого входного айтема\nlet title, url;\n\n// Берем метаданные (title, url) только из первого входного айтема, если он существует\nif (items.length > 0 && items[0].json) {\n    const firstInputItemJson = items[0].json;\n    title = firstInputItemJson.title;\n    url = firstInputItemJson.url;\n    // publishedAt и videoId также доступны, но в оригинале не использовались в выходе этого узла.\n}\n\n// Проходим по всем входным айтемам и собираем содержимое поля summary_points\nfor (const item of items) {\n    // Проверяем, существует ли поле summary_points в текущем айтеме\n    if (item.json && item.json.summary_points) {\n        // Добавляем содержимое summary_points текущего айтема к общей строке\n        // Просто конкатенируем, т.к. чистка ниже должна справиться с возможными разрывами\n        combinedRawJsonString += item.json.summary_points;\n    }\n}\n\n// Теперь работаем с объединенной сырой строкой\nlet cleanedJsonString = combinedRawJsonString;\n\n// --- Cleaning Steps ---\n\n// 1. Remove potential leading 'json' marker and surrounding whitespace/newlines.\ncleanedJsonString = cleanedJsonString.replace(/^\\s*```?\\s*json\\s*\\n*/, '');\n\n// 2. Remove potential trailing backticks (``` or `) and surrounding whitespace/newlines.\ncleanedJsonString = cleanedJsonString.replace(/\\s*```?\\s*$/, '');\n\n// 3. Trim any remaining leading/trailing whitespace.\ncleanedJsonString = cleanedJsonString.trim();\n\n// --- !!! WARNING !!! ---\n// The following step removes JSON structure characters ([ ] { }).\n// As noted in the original code, this makes the string invalid JSON and JSON.parse() in the next node WILL FAIL\n// if the next node expects valid JSON. This logic is kept as per your original code.\n\n// 4. Remove square brackets ([ ]) and curly braces ({ }) using a regex\ncleanedJsonString = cleanedJsonString.replace(/[\\[\\]\\{\\}]/g, '');\n\n// --- Prepare Output for the next node ---\n// Мы возвращаем один айтем, содержащий очищенную объединенную строку и метаданные из первого входного айтема.\nreturn [{\n    json: {\n        cleanedJsonString: cleanedJsonString, // Очищенная объединенная строка\n        title: title,                         // Оригинальный title из первого входного айтема\n        url: url                              // Оригинальный URL из первого входного айтема\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1960,
        460
      ],
      "id": "dedecf8c-1c5b-4291-961b-0ed911aa2d9a",
      "name": "remove json"
    },
    {
      "parameters": {
        "model": "google/gemma-3-27b-it",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2580,
        540
      ],
      "id": "ab1fe25c-8bf1-43ed-b8f3-3b4805efc1f0",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "xM1Kdr0j4QvJ4iaw",
          "name": "AdminN8N"
        }
      }
    },
    {
      "parameters": {
        "model": "openai/gpt-4.1",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2580,
        820
      ],
      "id": "a76df112-8e3e-46a8-bd08-90d5d1749980",
      "name": "OpenRouter Chat Model1",
      "credentials": {
        "openRouterApi": {
          "id": "xM1Kdr0j4QvJ4iaw",
          "name": "AdminN8N"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://openrouter.ai/api/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "=Authorization",
              "value": "=Bearer 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"
            },
            {
              "name": "=Content-Type",
              "value": "=application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "application/json",
        "body": "={\n  \"model\": \"google/gemini-2.5-pro-exp-03-25\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You are a translator. Your only task is to take the user’s input and output its English translation — nothing more. Do not add any commentary, explanations, apologies or extra sentences. If the input is already English, return it verbatim.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.transcript_original }}\"\n    }\n  ]\n}\n",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1960,
        160
      ],
      "id": "5133c885-39fd-48dc-9f59-3140fa27ece7",
      "name": "HTTP OpenRouter Request"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        2180,
        -40
      ],
      "id": "b432a153-9396-4db7-863b-9c4c4ece5f5b",
      "name": "Merge transcribation and title, url,  etc"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        2180,
        260
      ],
      "id": "e1e918d1-50f4-4974-9427-03d3429352c8",
      "name": "Merge OpenRouter and transcript"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        2980,
        240
      ],
      "id": "4a27ccc2-b9fc-43fe-a4e3-68c4d14abd41",
      "name": "Merge Chunks and title, url, etc"
    },
    {
      "parameters": {
        "jsCode": "// Получаем входные данные\nconst inputData = items;  // Это таблица с колонками Topic, Description и Title\n\n// Массив для хранения результата\nlet result = [];\n\n// Получаем title и url только из первого элемента\nconst title = inputData[0].json.title;\nconst url = inputData[0].json.url;\n\n// Переменная для отслеживания первой строки\nlet isFirstRow = true;\n\n// Проходим по всем строкам и добавляем title и url только для первой строки\ninputData.forEach(item => {\n    // Создаем объект для каждой строки\n    const row = {\n        json: {\n            Topic: item.json.Topic,          // Извлекаем Topic\n            Description: item.json.Description,  // Извлекаем Description\n            title: title  // Дублируем Title из первого элемента\n        }\n    };\n\n    // Добавляем url только для первой строки\n    if (isFirstRow) {\n        row.json.url = url;\n        isFirstRow = false; // После первой строки устанавливаем флаг в false\n    }\n\n    result.push(row);\n});\n\n// Возвращаем результат\nreturn result;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2440,
        460
      ],
      "id": "cdc6cfc2-6225-4127-bf56-eced94fce154",
      "name": "Add Titles to rows"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Generate a lesson theory without bullet points and description what students will be able to..., This project/learning centers/module... Write text like guide, not water AI answer using this materials:\nTitle: {{ $json.title }}\nTopic: {{ $json.Topic }}\nDescription: {{ $json.Description }}\n\nU need to write 2-3 paragraphs about Description that i gave you\n\nStart output from \"Lesson Description:\" \n\nDo not add any extra commentary\n"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        2680,
        460
      ],
      "id": "dd3daf5f-8c75-42cf-8eb9-9c450019938c",
      "name": "Theory Generator"
    },
    {
      "parameters": {
        "jsCode": "// Получаем все входные данные (input items)\nconst inputItems = items;\n\n// Массив для хранения результата\nlet mergedResult = [];\nlet fullText = '';  // Это будет наш объединенный текст\n\n// Проходим по всем входным данным и собираем текст\ninputItems.forEach(item => {\n    const lessonText = item.json.text;  // Извлекаем текст из каждого input\n\n    // Добавляем разрыв строки перед \"Lesson Description\", если это нужно\n    const formattedText = lessonText.replace(/(Lesson Description)/g, '\\n$1');\n    \n    // Добавляем к полному тексту\n    fullText += formattedText + ' ';\n});\n\n// Формируем итоговый объект\nmergedResult.push({\n    json: {\n        lessonText: fullText.trim()  // Склеиваем все Lesson Description в один блок\n    }\n});\n\n// Возвращаем объединенные данные\nreturn mergedResult;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3060,
        460
      ],
      "id": "abdb8df6-f653-48cc-a94b-bd5363655014",
      "name": "Theory Merger"
    },
    {
      "parameters": {
        "jsCode": "// Получаем динамический текст из входных данных\nconst inputString = $input.first().json.lessonText;\n\n// Функция для добавления числовых индексов перед каждым \"Lesson Description:\"\nconst addLessonNumber = (input) => {\n  let count = 1;\n  // Используем регулярное выражение для поиска всех вхождений \"Lesson Description:\"\n  return input.replace(/(Lesson Description:)/g, () => {\n    return `Lesson Description ${count++}:`;  // Вставляем номер урока перед \"Lesson Description:\"\n  });\n};\n\n// Применяем функцию добавления номеров уроков\nconst updatedString = addLessonNumber(inputString);\n\n// Возвращаем результат\nreturn [{ json: { updatedText: updatedString } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2440,
        700
      ],
      "id": "aad4ee38-5866-4a58-bb74-57c0dc8e641e",
      "name": "Add nums to Lesson Description"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Не пиши коментарии от себя\n\nЯ хочу преобразовать следующий текст в JSON-формат для описания онлайн-курса.\nОбщая информация о курсе:\nНа основе всего предоставленного текста сгенерируй общее название для курса (название не должно быть очень длинным, несколько слов).\nНа основе всего предоставленного текста сгенерируй общее описание для курса.\nКатегория курса: 680f332a16f8bb2b6ce9e71d\nУровень сложности: beginner\nИзображение курса: (оставьте пустым)\nПревью изображения курса: (оставьте пустым)\nМодули курса:\nДля каждого блока текста, начинающегося с \"Lesson Description\" и заканчивающегося перед следующим \"Lesson Description\" (или концом текста), создай отдельный модуль в массиве \"modules\".\nДля каждого модуля:\nЗаголовок модуля: Сгенерируй краткий заголовок, обобщающий содержание текущего \"Lesson Description\".\nОписание модуля: Сгенерируй краткое описание, обобщающее содержание текущего \"Lesson Description\".\nСодержание модуля (\"content\"): Скопируй полностью текст текущего \"Lesson Description\".\nУроки модуля (\"lessons\"): Создай массив, содержащий один объект урока.\nЗаголовок урока (\"title\"): Сформируй заголовок как \"Module №X\", где X - порядковый номер текущего \"Lesson Description\".\nСодержание урока (\"content\"): Скопируй полностью текст текущего \"Lesson Description\".\nДлительность урока (\"duration\"): 15\nТип урока (\"type\"): text\nТип контента (\"contentType\"): standard\nРесурсы урока (\"resources\"): []\nПрактические упражнения урока (\"practiceExercises\"): []\nБлоки контента урока (\"contentBlock\"): []\nТесты модуля (\"tests\"): []\nВходной текст:\n{{ $json.updatedText }}\nJSON Structure:\n{\n\"title\": \"(сгенерированное название курса)\",\n\"description\": \"(сгенерированное описание курса)\",\n\"category\": \"680f332a16f8bb2b6ce9e71d\",\n\"difficulty\": \"beginner\",\n\"image\": \"\",\n\"imagePreview\": \"\",\n\"modules\": [\n{\n\"title\": \"(сгенерированный заголовок модуля 1)\",\n\"description\": \"(сгенерированное описание модуля 1)\",\n\"content\": \"(текст Lesson Description 1)\",\n\"lessons\": [\n{\n\"title\": \"Module №1\",\n\"content\": \"(текст Lesson Description 1)\",\n\"duration\": 15,\n\"type\": \"text\",\n\"contentType\": \"standard\",\n\"resources\": [],\n\"practiceExercises\": [],\n\"contentBlocks\": []\n}\n],\n\"tests\": []\n},\n{\n\"title\": \"(сгенерированный заголовок модуля 2)\",\n\"description\": \"(сгенерированное описание модуля 2)\",\n\"content\": \"(текст Lesson Description 2)\",\n\"lessons\": [\n{\n\"title\": \"Module №2\",\n\"content\": \"(текст Lesson Description 2)\",\n\"duration\": 15,\n\"type\": \"text\",\n\"contentType\": \"standard\",\n\"resources\": [],\n\"practiceExercises\": [],\n\"contentBlocks\": []\n}\n],\n\"tests\": []\n},\n// ... и так далее для каждого Lesson Description должен быть сгенерирован модуль\n]\n}\nВажно: Обрати внимание, что общая информация о курсе (title, description, category, difficulty, image, imagePreview) указывается только один раз в начале JSON. Массив \"modules\" содержит объекты для каждого \"Lesson Description\". и Пиши на английском"
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        2680,
        720
      ],
      "id": "359311b5-7f58-4f5c-8f6d-7fa5f546fa6d",
      "name": "JSON generator"
    },
    {
      "parameters": {
        "jsCode": "// Получаем динамический текст из входных данных\nconst inputString = $input.first().json.text;\n\n// Функция для удаления лишних символов\nconst cleanString = (input) => {\n  return input\n    .replace(/```json\\n/g, '') // Убираем начало блока json\n    .replace(/```/g, '') // Убираем окончание блока json\n    .replace(/\\n/g, ' ') // Заменяем все \\n на пробелы\n    .replace(/\\s+/g, ' ') // Убираем лишние пробелы (заменяем несколько пробелов на один)\n    .trim(); // Убираем пробелы в начале и в конце\n};\n\n// Применяем функцию очистки\nconst cleanedString = cleanString(inputString);\n\n// Возвращаем очищенную строку\nreturn [{ json: { cleanedText: cleanedString } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3060,
        720
      ],
      "id": "47ceec2c-daac-4a74-91e9-2132a181b4df",
      "name": "Delete trash"
    },
    {
      "parameters": {
        "jsCode": "// Получаем очищенную строку из предыдущего узла\nconst cleanedJsonString = items[0].json.cleanedJsonString;\n\n// Шаблон для парсинга — регулярное выражение для извлечения topic и detail\nconst regex = /\"topic\":\\s*\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"\\s*,\\s*\"detail\":\\s*\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/gs;\n\n// Массив для хранения результата\nlet result = [];\nlet match;\n\n// Извлекаем метаданные из первого элемента\nconst title = items[0].json.title;\nconst url = items[0].json.url;\n\n// Проходим по строкам и извлекаем значения для topic и description\nlet isFirstRow = true; // Переменная для отслеживания первой строки\nwhile ((match = regex.exec(cleanedJsonString)) !== null) {\n    // match[1] содержит значение 'topic'\n    // match[3] содержит значение 'detail'\n    let row = {\n        json: {\n            Topic: match[1],       // Тема\n            Description: match[3]  // Описание\n        }\n    };\n\n    // Добавляем title и url только для первой строки\n    if (isFirstRow) {\n        row.json.title = title;\n        row.json.url = url;\n        isFirstRow = false; // После первой строки устанавливаем флаг в false\n    }\n\n    result.push(row);\n}\n\n// Возвращаем результат в формате, где каждая строка представляет собой объект с Topic, Description, title и url (для первой строки)\nreturn result;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2180,
        460
      ],
      "id": "873853ac-dea9-4b4f-9dfb-3c36da8c1257",
      "name": "Code1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "da25e488-44b3-4253-b716-f565a6981cd6",
              "leftValue": "={{ $json.joinedText }}",
              "rightValue": "```json",
              "operator": {
                "type": "string",
                "operation": "contains"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        660,
        -40
      ],
      "id": "ad954c44-b86a-4d9e-8f60-ffecd4e931eb",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "// Получаем динамический текст из входных данных\nconst inputString = $input.first().json.joinedText;\n\n// Функция для удаления лишних символов\nconst cleanString = (input) => {\n  return input\n    .replace(/```json\\n/g, '') // Убираем начало блока json\n    .replace(/```/g, '') // Убираем окончание блока json\n    .replace(/\\n/g, ' ') // Заменяем все \\n на пробелы\n    .replace(/\\s+/g, ' ') // Убираем лишние пробелы (заменяем несколько пробелов на один)\n    .trim(); // Убираем пробелы в начале и в конце\n};\n\n// Применяем функцию очистки\nconst cleanedString = cleanString(inputString);\n\n// Возвращаем очищенную строку\nreturn [{ json: { cleanedText: cleanedString } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        860,
        -160
      ],
      "id": "2f4417d4-48ea-44cc-a8fd-276c32aa70fa",
      "name": "Delete trash1"
    },
    {
      "parameters": {
        "jsCode": "// items[0].json.cleanedText — это твой JSON в виде строки\nconst raw = items[0].json.cleanedText;\n\n// Если внутри строки используются одинарные кавычки вместо двойных,\n// раскомментируй следующую строку, чтобы привести к валидному JSON:\n// const fixed = raw.replace(/'/g, '\"');\n\n// Парсим строку в массив объектов\nconst arr = JSON.parse(raw /* или fixed */);\n\n// Преобразуем каждый объект в отдельный item n8n\nreturn arr.map(obj => ({\n  json: obj\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1020,
        -160
      ],
      "id": "436e4305-f8b0-44ab-b257-af668ea94877",
      "name": "Code2"
    },
    {
      "parameters": {
        "mode": "combine",
        "fieldsToMatchString": " video_link",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        1340,
        0
      ],
      "id": "6c4c82ae-98b2-4a41-a4e9-ac7fdbd436e3",
      "name": "Merge"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "HTTP Request to make.com",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cleans text and splits into lines": {
      "main": [
        [
          {
            "node": "Joins lines into single text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request to make.com": {
      "main": [
        [
          {
            "node": "Cleans text and splits into lines",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Joins lines into single text": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Filter": {
      "main": [
        [
          {
            "node": "add transcript_original",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "youtube video parser": {
      "main": [
        [
          {
            "node": "Merge transcribation and title, url,  etc",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "add transcript_original": {
      "main": [
        [
          {
            "node": "HTTP OpenRouter Request",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge OpenRouter and transcript",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Chat Completion": {
      "main": [
        [
          {
            "node": "Merge Chunks and title, url, etc",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split to Chunks": {
      "main": [
        [
          {
            "node": "Chat Completion",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Chunks and title, url, etc",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Summarizer": {
      "main": [
        [
          {
            "node": "remove json",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse title ulr and publishedAt": {
      "main": [
        [
          {
            "node": "youtube video parser",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge transcribation and title, url,  etc",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "remove json": {
      "main": [
        [
          {
            "node": "Code1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Theory Generator",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "JSON generator",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "HTTP OpenRouter Request": {
      "main": [
        [
          {
            "node": "Merge OpenRouter and transcript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge transcribation and title, url,  etc": {
      "main": [
        [
          {
            "node": "Error Filter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge OpenRouter and transcript": {
      "main": [
        [
          {
            "node": "Split to Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Chunks and title, url, etc": {
      "main": [
        [
          {
            "node": "Summarizer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Titles to rows": {
      "main": [
        [
          {
            "node": "Theory Generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Theory Generator": {
      "main": [
        [
          {
            "node": "Theory Merger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Theory Merger": {
      "main": [
        [
          {
            "node": "Add nums to Lesson Description",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add nums to Lesson Description": {
      "main": [
        [
          {
            "node": "JSON generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JSON generator": {
      "main": [
        [
          {
            "node": "Delete trash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code1": {
      "main": [
        [
          {
            "node": "Add Titles to rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Delete trash1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete trash1": {
      "main": [
        [
          {
            "node": "Code2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code2": {
      "main": [
        [
          {
            "node": "Parse title ulr and publishedAt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        []
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {},
  "versionId": "3dd32ca1-57a2-4612-abb0-ee14dd99d7a4",
  "triggerCount": 0,
  "tags": []
}